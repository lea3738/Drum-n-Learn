// tone@15.0.4 downloaded from https://ga.jspm.io/npm:tone@15.0.4/build/esm/index.js

import{g as t,O as s,s as o,T as n,a as r,o as l,b as u,c as p,r as m,n as _,d as v,e as w,f as k,h as q,i as R,j as V,k as L,l as Q,m as H,p as U,q as W,t as J,u as $,w as K,v as X}from"../../_/F77li6UX.js";export{B as BaseContext,C as Context,E as Emitter,D as debug,y as isFunction,z as isNote,x as start,A as version}from"../../_/F77li6UX.js";import{S as Y,C as tt,a as et,T as st}from"../../_/vkqVwB5F.js";export{I as IntervalTimeline,b as Ticks}from"../../_/vkqVwB5F.js";export{D as Delay}from"../../_/DQb7LgMG.js";import{Gain as it}from"./core/context/Gain.js";import{__awaiter as ot,__decorate as nt}from"tslib";import"./core/context/Listener.js";import{T as at,a as rt,b as ht,F as ct,P as lt,c as ut}from"../../_/UihCRm6P.js";export{g as Frequency,i as Time,h as TimeClass,j as TransportTime,d as connect,e as disconnect,f as fanIn}from"../../_/UihCRm6P.js";import{T as pt}from"../../_/eZ2MIrkw.js";export{S as Sampler}from"../../_/eZ2MIrkw.js";export{a as Midi,M as MidiClass,P as PolySynth}from"../../_/z2Y4G7ON.js";import{intervalToFrequencyRatio as dt,dbToGain as mt,gainToDb as _t}from"./core/type/Conversions.js";export{ftom,mtof}from"./core/type/Conversions.js";import{Noise as ft}from"./source/Noise.js";export{UserMedia}from"./source/UserMedia.js";export{O as Oscillator,T as ToneOscillatorNode}from"../../_/52r2iJSW.js";import{M as gt,F as vt}from"../../_/AIvBY60y.js";export{A as AMOscillator,a as FatOscillator,O as OmniOscillator,b as PWMOscillator,P as PulseOscillator}from"../../_/AIvBY60y.js";import{L as bt}from"../../_/rjICFN1j.js";export{Z as Zero}from"../../_/rjICFN1j.js";import{T as yt}from"../../_/9m5Zmx5f.js";import{Player as xt}from"./source/buffer/Player.js";import{Volume as St}from"./component/channel/Volume.js";export{A as Add}from"../../_/gpL_6mRA.js";import{O as wt,F as kt}from"../../_/sSUjHF1B.js";export{A as Abs,a as AutoWah,S as ScaleExp}from"../../_/sSUjHF1B.js";export{A as AudioToGain}from"../../_/ka97xd8i.js";export{C as CrossFade,G as GainToAudio}from"../../_/SPJdt_dq.js";import{S as Dt,M as Tt,a as Ft}from"../../_/uA5LJ9kL.js";export{b as StereoWidener}from"../../_/uA5LJ9kL.js";import{S as jt,T as Et}from"../../_/BcafeaZ9.js";export{c as connectSignal}from"../../_/BcafeaZ9.js";import{S as qt,W as Rt}from"../../_/16kV7KS6.js";import{M as Ot}from"../../_/sDLkJMkG.js";export{N as Negate}from"../../_/b0ZFMrNG.js";export{P as Pow}from"../../_/a1v5LTUG.js";import{S as Ct}from"../../_/QLszilud.js";export{AMSynth}from"./instrument/AMSynth.js";import{M as At}from"../../_/cRmNIP3R.js";export{F as FrequencyEnvelope}from"../../_/cRmNIP3R.js";export{FMSynth}from"./instrument/FMSynth.js";import{E as Mt,A as zt}from"../../_/s2K8uxKn.js";import{F as Vt}from"../../_/fTzE5fjw.js";export{B as BiquadFilter}from"../../_/fTzE5fjw.js";import{Synth as Pt}from"./instrument/Synth.js";import{r as Gt,t as Lt}from"../../_/AJIDQK0J.js";import{Instrument as It}from"./instrument/Instrument.js";import{a as Qt,r as Nt,T as Bt}from"../../_/Ts4EF5QM.js";export{B as BitCrusher}from"../../_/Ts4EF5QM.js";import{L as Ht}from"../../_/t6r839gK.js";export{A as AutoFilter}from"../../_/t6r839gK.js";export{Chebyshev}from"./effect/Chebyshev.js";export{Chorus}from"./effect/Chorus.js";export{Distortion}from"./effect/Distortion.js";export{FeedbackDelay}from"./effect/FeedbackDelay.js";export{FrequencyShifter}from"./effect/FrequencyShifter.js";import{S as Ut}from"../../_/y4UmHtH2.js";export{PingPongDelay}from"./effect/PingPongDelay.js";export{PitchShift}from"./effect/PitchShift.js";export{Phaser}from"./effect/Phaser.js";export{Reverb}from"./effect/Reverb.js";export{Tremolo}from"./effect/Tremolo.js";export{Vibrato}from"./effect/Vibrato.js";import{M as Wt}from"../../_/39VJ7BXG.js";export{A as Analyser}from"../../_/39VJ7BXG.js";export{Meter}from"./component/analysis/Meter.js";export{FFT}from"./component/analysis/FFT.js";export{Waveform}from"./component/analysis/Waveform.js";import{M as Zt}from"../../_/i2AIidQD.js";export{Panner3D}from"./component/channel/Panner3D.js";export{S as Split}from"../../_/zlzqfiYK.js";export{isSupported as supported}from"standardized-audio-context";import"../../_/1vOajvap.js";import"../../_/oDX7-Oga.js";import"../../_/F_U9_4ak.js";import"../../_/uINgETa4.js";import"../../_/iPvf88Lj.js";
/**
 * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.
 * The OfflineAudioContext is capable of rendering much faster than real time in many cases.
 * The callback function also passes in an offline instance of {@link Context} which can be used
 * to schedule events along the Transport.
 * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
 * @param  duration     the amount of time to record for.
 * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.
 * @example
 * // render 2 seconds of the oscillator
 * Tone.Offline(() => {
 * 	// only nodes created in this callback will be recorded
 * 	const oscillator = new Tone.Oscillator().toDestination().start(0);
 * }, 2).then((buffer) => {
 * 	// do something with the output buffer
 * 	console.log(buffer);
 * });
 * @example
 * // can also schedule events along the Transport
 * // using the passed in Offline Transport
 * Tone.Offline(({ transport }) => {
 * 	const osc = new Tone.Oscillator().toDestination();
 * 	transport.schedule(time => {
 * 		osc.start(time).stop(time + 0.1);
 * 	}, 1);
 * 	// make sure to start the transport
 * 	transport.start(0.2);
 * }, 4).then((buffer) => {
 * 	// do something with the output buffer
 * 	console.log(buffer);
 * });
 * @category Core
 */function Offline(e,i){return ot(this,arguments,void 0,(function*(e,i,a=2,r=t().sampleRate){const h=t();const c=new s(a,i,r);o(c);yield e(c);const l=c.render();o(h);const u=yield l;return new n(u)}))}class DrawClass extends at{constructor(){super(...arguments);this.name="Draw";this.expiration=.25;this.anticipation=.008;this._events=new r;this._boundDrawLoop=this._drawLoop.bind(this);this._animationFrame=-1}
/**
     * Schedule a function at the given time to be invoked
     * on the nearest animation frame.
     * @param  callback  Callback is invoked at the given time.
     * @param  time      The time relative to the AudioContext time to invoke the callback.
     * @example
     * Tone.Transport.scheduleRepeat(time => {
     * 	Tone.Draw.schedule(() => console.log(time), time);
     * }, 1);
     * Tone.Transport.start();
     */schedule(t,e){this._events.add({callback:t,time:this.toSeconds(e)});this._events.length===1&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop));return this}
/**
     * Cancel events scheduled after the given time
     * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
     */cancel(t){this._events.cancel(this.toSeconds(t));return this}_drawLoop(){const t=this.context.currentTime;while(this._events.length&&this._events.peek().time-this.anticipation<=t){const e=this._events.shift();e&&t-e.time<=this.expiration&&e.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){super.dispose();this._events.dispose();cancelAnimationFrame(this._animationFrame);return this}}l((t=>{t.draw=new DrawClass({context:t})}));u((t=>{t.draw.dispose()}));var Jt=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));class Players extends rt{constructor(){const t=p(Players.getDefaults(),arguments,["urls","onload"],"urls");super(t);this.name="Players";this.input=void 0;this._players=new Map;this._volume=this.output=new St({context:this.context,volume:t.volume});this.volume=this._volume.volume;m(this,"volume");this._buffers=new pt({urls:t.urls,onload:t.onload,baseUrl:t.baseUrl,onerror:t.onerror});this.mute=t.mute;this._fadeIn=t.fadeIn;this._fadeOut=t.fadeOut}static getDefaults(){return Object.assign(Y.getDefaults(),{baseUrl:"",fadeIn:0,fadeOut:0,mute:false,onload:_,onerror:_,urls:{},volume:0})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}get fadeIn(){return this._fadeIn}set fadeIn(t){this._fadeIn=t;this._players.forEach((e=>{e.fadeIn=t}))}get fadeOut(){return this._fadeOut}set fadeOut(t){this._fadeOut=t;this._players.forEach((e=>{e.fadeOut=t}))}get state(){const t=Array.from(this._players).some((([t,e])=>e.state==="started"));return t?"started":"stopped"}
/**
     * True if the buffers object has a buffer by that name.
     * @param name  The key or index of the buffer.
     */has(t){return this._buffers.has(t)}
/**
     * Get a player by name.
     * @param  name  The players name as defined in the constructor object or `add` method.
     */player(t){v(this.has(t),`No Player with the name ${t} exists on this object`);if(!this._players.has(t)){const e=new xt({context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,url:this._buffers.get(t)}).connect(this.output);this._players.set(t,e)}return this._players.get(t)}get loaded(){return this._buffers.loaded}
/**
     * Add a player by name and url to the Players
     * @param  name A unique name to give the player
     * @param  url  Either the url of the bufer or a buffer which will be added with the given name.
     * @param callback  The callback to invoke when the url is loaded.
     * @example
     * const players = new Tone.Players();
     * players.add("gong", "https://tonejs.github.io/audio/berklee/gong_1.mp3", () => {
     * 	console.log("gong loaded");
     * 	players.player("gong").start();
     * });
     */add(t,e,s){v(!this._buffers.has(t),"A buffer with that name already exists on this object");this._buffers.add(t,e,s);return this}
/**
     * Stop all of the players at the given time
     * @param time The time to stop all of the players.
     */stopAll(t){this._players.forEach((e=>e.stop(t)));return this}dispose(){super.dispose();this._volume.dispose();this.volume.dispose();this._players.forEach((t=>t.dispose()));this._buffers.dispose();return this}}class GrainPlayer extends Y{constructor(){const t=p(GrainPlayer.getDefaults(),arguments,["url","onload"]);super(t);this.name="GrainPlayer";this._loopStart=0;this._loopEnd=0;this._activeSources=[];this.buffer=new n({onload:t.onload,onerror:t.onerror,reverse:t.reverse,url:t.url});this._clock=new tt({context:this.context,callback:this._tick.bind(this),frequency:1/t.grainSize});this._playbackRate=t.playbackRate;this._grainSize=t.grainSize;this._overlap=t.overlap;this.detune=t.detune;this.overlap=t.overlap;this.loop=t.loop;this.playbackRate=t.playbackRate;this.grainSize=t.grainSize;this.loopStart=t.loopStart;this.loopEnd=t.loopEnd;this.reverse=t.reverse;this._clock.on("stop",this._onstop.bind(this))}static getDefaults(){return Object.assign(Y.getDefaults(),{onload:_,onerror:_,overlap:.1,grainSize:.2,playbackRate:1,detune:0,loop:false,loopStart:0,loopEnd:0,reverse:false})}_start(t,e,s){e=w(e,0);e=this.toSeconds(e);t=this.toSeconds(t);const i=1/this._clock.frequency.getValueAtTime(t);this._clock.start(t,e/i);s&&this.stop(t+this.toSeconds(s))}
/**
     * Stop and then restart the player from the beginning (or offset)
     * @param  time When the player should start.
     * @param  offset The offset from the beginning of the sample to start at.
     * @param  duration How long the sample should play. If no duration is given,
     * 					it will default to the full length of the sample (minus any offset)
     */restart(t,e,s){super.restart(t,e,s);return this}_restart(t,e,s){this._stop(t);this._start(t,e,s)}_stop(t){this._clock.stop(t)}_onstop(t){this._activeSources.forEach((e=>{e.fadeOut=0;e.stop(t)}));this.onstop(this)}_tick(t){const e=this._clock.getTicksAtTime(t);const s=e*this._grainSize;this.log("offset",s);if(!this.loop&&s>this.buffer.duration){this.stop(t);return}const i=s<this._overlap?0:this._overlap;const o=new yt({context:this.context,url:this.buffer,fadeIn:i,fadeOut:this._overlap,loop:this.loop,loopStart:this._loopStart,loopEnd:this._loopEnd,playbackRate:dt(this.detune/100)}).connect(this.output);o.start(t,this._grainSize*e);o.stop(t+this._grainSize/this.playbackRate);this._activeSources.push(o);o.onended=()=>{const t=this._activeSources.indexOf(o);t!==-1&&this._activeSources.splice(t,1)}}get playbackRate(){return this._playbackRate}set playbackRate(t){k(t,.001);this._playbackRate=t;this.grainSize=this._grainSize}get loopStart(){return this._loopStart}set loopStart(t){this.buffer.loaded&&k(this.toSeconds(t),0,this.buffer.duration);this._loopStart=this.toSeconds(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this.buffer.loaded&&k(this.toSeconds(t),0,this.buffer.duration);this._loopEnd=this.toSeconds(t)}get reverse(){return this.buffer.reverse}set reverse(t){this.buffer.reverse=t}get grainSize(){return this._grainSize}set grainSize(t){this._grainSize=this.toSeconds(t);this._clock.frequency.setValueAtTime(this._playbackRate/this._grainSize,this.now())}get overlap(){return this._overlap}set overlap(t){const e=this.toSeconds(t);k(e,0);this._overlap=e}get loaded(){return this.buffer.loaded}dispose(){super.dispose();this.buffer.dispose();this._clock.dispose();this._activeSources.forEach((t=>t.dispose()));return this}}class GreaterThanZero extends qt{constructor(){super(p(GreaterThanZero.getDefaults(),arguments));this.name="GreaterThanZero";this._thresh=this.output=new Rt({context:this.context,length:127,mapping:t=>t<=0?0:1});this._scale=this.input=new Ot({context:this.context,value:1e4});this._scale.connect(this._thresh)}dispose(){super.dispose();this._scale.dispose();this._thresh.dispose();return this}}class GreaterThan extends jt{constructor(){const t=p(GreaterThan.getDefaults(),arguments,["value"]);super(t);this.name="GreaterThan";this.override=false;this._subtract=this.input=new Dt({context:this.context,value:t.value});this._gtz=this.output=new GreaterThanZero({context:this.context});this.comparator=this._param=this._subtract.subtrahend;m(this,"comparator");this._subtract.connect(this._gtz)}static getDefaults(){return Object.assign(jt.getDefaults(),{value:0})}dispose(){super.dispose();this._gtz.dispose();this._subtract.dispose();this.comparator.dispose();return this}}class SyncedSignal extends jt{constructor(){const t=p(jt.getDefaults(),arguments,["value","units"]);super(t);this.name="SyncedSignal";this.override=false;this._lastVal=t.value;this._synced=this.context.transport.scheduleRepeat(this._onTick.bind(this),"1i");this._syncedCallback=this._anchorValue.bind(this);this.context.transport.on("start",this._syncedCallback);this.context.transport.on("pause",this._syncedCallback);this.context.transport.on("stop",this._syncedCallback);this._constantSource.disconnect();this._constantSource.stop(0);this._constantSource=this.output=new Et({context:this.context,offset:t.value,units:t.units}).start(0);this.setValueAtTime(t.value,0)}_onTick(t){const e=super.getValueAtTime(this.context.transport.seconds);if(this._lastVal!==e){this._lastVal=e;this._constantSource.offset.setValueAtTime(e,t)}}_anchorValue(t){const e=super.getValueAtTime(this.context.transport.seconds);this._lastVal=e;this._constantSource.offset.cancelAndHoldAtTime(t);this._constantSource.offset.setValueAtTime(e,t)}getValueAtTime(t){const e=new ht(this.context,t).toSeconds();return super.getValueAtTime(e)}setValueAtTime(t,e){const s=new ht(this.context,e).toSeconds();super.setValueAtTime(t,s);return this}linearRampToValueAtTime(t,e){const s=new ht(this.context,e).toSeconds();super.linearRampToValueAtTime(t,s);return this}exponentialRampToValueAtTime(t,e){const s=new ht(this.context,e).toSeconds();super.exponentialRampToValueAtTime(t,s);return this}setTargetAtTime(t,e,s){const i=new ht(this.context,e).toSeconds();super.setTargetAtTime(t,i,s);return this}cancelScheduledValues(t){const e=new ht(this.context,t).toSeconds();super.cancelScheduledValues(e);return this}setValueCurveAtTime(t,e,s,i){const o=new ht(this.context,e).toSeconds();s=this.toSeconds(s);super.setValueCurveAtTime(t,o,s,i);return this}cancelAndHoldAtTime(t){const e=new ht(this.context,t).toSeconds();super.cancelAndHoldAtTime(e);return this}setRampPoint(t){const e=new ht(this.context,t).toSeconds();super.setRampPoint(e);return this}exponentialRampTo(t,e,s){const i=new ht(this.context,s).toSeconds();super.exponentialRampTo(t,e,i);return this}linearRampTo(t,e,s){const i=new ht(this.context,s).toSeconds();super.linearRampTo(t,e,i);return this}targetRampTo(t,e,s){const i=new ht(this.context,s).toSeconds();super.targetRampTo(t,e,i);return this}dispose(){super.dispose();this.context.transport.clear(this._synced);this.context.transport.off("start",this._syncedCallback);this.context.transport.off("pause",this._syncedCallback);this.context.transport.off("stop",this._syncedCallback);this._constantSource.dispose();return this}}class DuoSynth extends gt{constructor(){const t=p(DuoSynth.getDefaults(),arguments);super(t);this.name="DuoSynth";this.voice0=new At(Object.assign(t.voice0,{context:this.context,onsilence:()=>this.onsilence(this)}));this.voice1=new At(Object.assign(t.voice1,{context:this.context}));this.harmonicity=new Ot({context:this.context,units:"positive",value:t.harmonicity});this._vibrato=new bt({frequency:t.vibratoRate,context:this.context,min:-50,max:50});this._vibrato.start();this.vibratoRate=this._vibrato.frequency;this._vibratoGain=new it({context:this.context,units:"normalRange",gain:t.vibratoAmount});this.vibratoAmount=this._vibratoGain.gain;this.frequency=new jt({context:this.context,units:"frequency",value:440});this.detune=new jt({context:this.context,units:"cents",value:t.detune});this.frequency.connect(this.voice0.frequency);this.frequency.chain(this.harmonicity,this.voice1.frequency);this._vibrato.connect(this._vibratoGain);this._vibratoGain.fan(this.voice0.detune,this.voice1.detune);this.detune.fan(this.voice0.detune,this.voice1.detune);this.voice0.connect(this.output);this.voice1.connect(this.output);m(this,["voice0","voice1","frequency","vibratoAmount","vibratoRate"])}getLevelAtTime(t){t=this.toSeconds(t);return this.voice0.envelope.getValueAtTime(t)+this.voice1.envelope.getValueAtTime(t)}static getDefaults(){return R(gt.getDefaults(),{vibratoAmount:.5,vibratoRate:5,harmonicity:1.5,voice0:R(q(At.getDefaults(),Object.keys(gt.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}}),voice1:R(q(At.getDefaults(),Object.keys(gt.getDefaults())),{filterEnvelope:{attack:.01,decay:0,sustain:1,release:.5},envelope:{attack:.01,decay:0,sustain:1,release:.5}})})}_triggerEnvelopeAttack(t,e){this.voice0._triggerEnvelopeAttack(t,e);this.voice1._triggerEnvelopeAttack(t,e)}_triggerEnvelopeRelease(t){this.voice0._triggerEnvelopeRelease(t);this.voice1._triggerEnvelopeRelease(t);return this}dispose(){super.dispose();this.voice0.dispose();this.voice1.dispose();this.frequency.dispose();this.detune.dispose();this._vibrato.dispose();this.vibratoRate.dispose();this._vibratoGain.dispose();this.harmonicity.dispose();return this}}const $t=[1,1.483,1.932,2.546,2.63,3.897];class MetalSynth extends gt{constructor(){const t=p(MetalSynth.getDefaults(),arguments);super(t);this.name="MetalSynth";this._oscillators=[];this._freqMultipliers=[];this.detune=new jt({context:this.context,units:"cents",value:t.detune});this.frequency=new jt({context:this.context,units:"frequency"});this._amplitude=new it({context:this.context,gain:0}).connect(this.output);this._highpass=new Vt({Q:0,context:this.context,type:"highpass"}).connect(this._amplitude);for(let e=0;e<$t.length;e++){const s=new vt({context:this.context,harmonicity:t.harmonicity,modulationIndex:t.modulationIndex,modulationType:"square",onstop:e===0?()=>this.onsilence(this):_,type:"square"});s.connect(this._highpass);this._oscillators[e]=s;const i=new Ot({context:this.context,value:$t[e]});this._freqMultipliers[e]=i;this.frequency.chain(i,s.frequency);this.detune.connect(s.detune)}this._filterFreqScaler=new Ct({context:this.context,max:7e3,min:this.toFrequency(t.resonance)});this.envelope=new Mt({attack:t.envelope.attack,attackCurve:"linear",context:this.context,decay:t.envelope.decay,release:t.envelope.release,sustain:0});this.envelope.chain(this._filterFreqScaler,this._highpass.frequency);this.envelope.connect(this._amplitude.gain);this._octaves=t.octaves;this.octaves=t.octaves}static getDefaults(){return R(gt.getDefaults(),{envelope:Object.assign(q(Mt.getDefaults(),Object.keys(rt.getDefaults())),{attack:.001,decay:1.4,release:.2}),harmonicity:5.1,modulationIndex:32,octaves:1.5,resonance:4e3})}
/**
     * Trigger the attack.
     * @param time When the attack should be triggered.
     * @param velocity The velocity that the envelope should be triggered at.
     */_triggerEnvelopeAttack(t,e=1){this.envelope.triggerAttack(t,e);this._oscillators.forEach((e=>e.start(t)));this.envelope.sustain===0&&this._oscillators.forEach((e=>{e.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay))}));return this}
/**
     * Trigger the release of the envelope.
     * @param time When the release should be triggered.
     */_triggerEnvelopeRelease(t){this.envelope.triggerRelease(t);this._oscillators.forEach((e=>e.stop(t+this.toSeconds(this.envelope.release))));return this}getLevelAtTime(t){t=this.toSeconds(t);return this.envelope.getValueAtTime(t)}get modulationIndex(){return this._oscillators[0].modulationIndex.value}set modulationIndex(t){this._oscillators.forEach((e=>e.modulationIndex.value=t))}get harmonicity(){return this._oscillators[0].harmonicity.value}set harmonicity(t){this._oscillators.forEach((e=>e.harmonicity.value=t))}get resonance(){return this._filterFreqScaler.min}set resonance(t){this._filterFreqScaler.min=this.toFrequency(t);this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(t){this._octaves=t;this._filterFreqScaler.max=this._filterFreqScaler.min*Math.pow(2,t)}dispose(){super.dispose();this._oscillators.forEach((t=>t.dispose()));this._freqMultipliers.forEach((t=>t.dispose()));this.frequency.dispose();this.detune.dispose();this._filterFreqScaler.dispose();this._amplitude.dispose();this.envelope.dispose();this._highpass.dispose();return this}}class MembraneSynth extends Pt{constructor(){const t=p(MembraneSynth.getDefaults(),arguments);super(t);this.name="MembraneSynth";this.portamento=0;this.pitchDecay=t.pitchDecay;this.octaves=t.octaves;m(this,["oscillator","envelope"])}static getDefaults(){return R(gt.getDefaults(),Pt.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(t,e){const s=this.toSeconds(e);const i=this.toFrequency(t instanceof ct?t.toFrequency():t);const o=i*this.octaves;this.oscillator.frequency.setValueAtTime(o,s);this.oscillator.frequency.exponentialRampToValueAtTime(i,s+this.toSeconds(this.pitchDecay));return this}dispose(){super.dispose();return this}}nt([Gt(0)],MembraneSynth.prototype,"octaves",void 0);nt([Lt(0)],MembraneSynth.prototype,"pitchDecay",void 0);class NoiseSynth extends It{constructor(){const t=p(NoiseSynth.getDefaults(),arguments);super(t);this.name="NoiseSynth";this.noise=new ft(Object.assign({context:this.context},t.noise));this.envelope=new zt(Object.assign({context:this.context},t.envelope));this.noise.chain(this.envelope,this.output)}static getDefaults(){return Object.assign(It.getDefaults(),{envelope:Object.assign(q(Mt.getDefaults(),Object.keys(rt.getDefaults())),{decay:.1,sustain:0}),noise:Object.assign(q(ft.getDefaults(),Object.keys(Y.getDefaults())),{type:"white"})})}triggerAttack(t,e=1){t=this.toSeconds(t);this.envelope.triggerAttack(t,e);this.noise.start(t);this.envelope.sustain===0&&this.noise.stop(t+this.toSeconds(this.envelope.attack)+this.toSeconds(this.envelope.decay));return this}triggerRelease(t){t=this.toSeconds(t);this.envelope.triggerRelease(t);this.noise.stop(t+this.toSeconds(this.envelope.release));return this}sync(){if(this._syncState()){this._syncMethod("triggerAttack",0);this._syncMethod("triggerRelease",0)}return this}
/**
     * Trigger the attack and then the release after the duration.
     * @param duration The amount of time to hold the note for
     * @param time The time the note should start
     * @param velocity The volume of the note (0-1)
     * @example
     * const noiseSynth = new Tone.NoiseSynth().toDestination();
     * // hold the note for 0.5 seconds
     * noiseSynth.triggerAttackRelease(0.5);
     */triggerAttackRelease(t,e,s=1){e=this.toSeconds(e);t=this.toSeconds(t);this.triggerAttack(e,s);this.triggerRelease(e+t);return this}dispose(){super.dispose();this.noise.dispose();this.envelope.dispose();return this}}const Kt="\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n";Qt(Kt);const Xt="feedback-comb-filter";const Yt='\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: "delayTime",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}, {\n\t\t\t\tname: "feedback",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: "k-rate"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n';Nt(Xt,Yt);class FeedbackCombFilter extends Bt{constructor(){const t=p(FeedbackCombFilter.getDefaults(),arguments,["delayTime","resonance"]);super(t);this.name="FeedbackCombFilter";this.input=new it({context:this.context});this.output=new it({context:this.context});this.delayTime=new lt({context:this.context,value:t.delayTime,units:"time",minValue:0,maxValue:1,param:this._dummyParam,swappable:true});this.resonance=new lt({context:this.context,value:t.resonance,units:"normalRange",param:this._dummyParam,swappable:true});m(this,["resonance","delayTime"])}_audioWorkletName(){return Xt}static getDefaults(){return Object.assign(rt.getDefaults(),{delayTime:.1,resonance:.5})}onReady(t){ut(this.input,t,this.output);const e=t.parameters.get("delayTime");this.delayTime.setParam(e);const s=t.parameters.get("feedback");this.resonance.setParam(s)}dispose(){super.dispose();this.input.dispose();this.output.dispose();this.delayTime.dispose();this.resonance.dispose();return this}}class LowpassCombFilter extends rt{constructor(){const t=p(LowpassCombFilter.getDefaults(),arguments,["delayTime","resonance","dampening"]);super(t);this.name="LowpassCombFilter";this._combFilter=this.output=new FeedbackCombFilter({context:this.context,delayTime:t.delayTime,resonance:t.resonance});this.delayTime=this._combFilter.delayTime;this.resonance=this._combFilter.resonance;this._lowpass=this.input=new wt({context:this.context,frequency:t.dampening,type:"lowpass"});this._lowpass.connect(this._combFilter)}static getDefaults(){return Object.assign(rt.getDefaults(),{dampening:3e3,delayTime:.1,resonance:.5})}get dampening(){return this._lowpass.frequency}set dampening(t){this._lowpass.frequency=t}dispose(){super.dispose();this._combFilter.dispose();this._lowpass.dispose();return this}}class PluckSynth extends It{constructor(){const t=p(PluckSynth.getDefaults(),arguments);super(t);this.name="PluckSynth";this._noise=new ft({context:this.context,type:"pink"});this.attackNoise=t.attackNoise;this._lfcf=new LowpassCombFilter({context:this.context,dampening:t.dampening,resonance:t.resonance});this.resonance=t.resonance;this.release=t.release;this._noise.connect(this._lfcf);this._lfcf.connect(this.output)}static getDefaults(){return R(It.getDefaults(),{attackNoise:1,dampening:4e3,resonance:.7,release:1})}get dampening(){return this._lfcf.dampening}set dampening(t){this._lfcf.dampening=t}triggerAttack(t,e){const s=this.toFrequency(t);e=this.toSeconds(e);const i=1/s;this._lfcf.delayTime.setValueAtTime(i,e);this._noise.start(e);this._noise.stop(e+i*this.attackNoise);this._lfcf.resonance.cancelScheduledValues(e);this._lfcf.resonance.setValueAtTime(this.resonance,e);return this}triggerRelease(t){this._lfcf.resonance.linearRampTo(0,this.release,t);return this}dispose(){super.dispose();this._noise.dispose();this._lfcf.dispose();return this}}class ToneEvent extends at{constructor(){const t=p(ToneEvent.getDefaults(),arguments,["callback","value"]);super(t);this.name="ToneEvent";this._state=new et("stopped");this._startOffset=0;this._loop=t.loop;this.callback=t.callback;this.value=t.value;this._loopStart=this.toTicks(t.loopStart);this._loopEnd=this.toTicks(t.loopEnd);this._playbackRate=t.playbackRate;this._probability=t.probability;this._humanize=t.humanize;this.mute=t.mute;this._playbackRate=t.playbackRate;this._state.increasing=true;this._rescheduleEvents()}static getDefaults(){return Object.assign(at.getDefaults(),{callback:_,humanize:false,loop:false,loopEnd:"1m",loopStart:0,mute:false,playbackRate:1,probability:1,value:null})}
/**
     * Reschedule all of the events along the timeline
     * with the updated values.
     * @param after Only reschedules events after the given time.
     */_rescheduleEvents(t=-1){this._state.forEachFrom(t,(t=>{let e;if(t.state==="started"){t.id!==-1&&this.context.transport.clear(t.id);const s=t.time+Math.round(this.startOffset/this._playbackRate);if(this._loop===true||V(this._loop)&&this._loop>1){e=Infinity;V(this._loop)&&(e=this._loop*this._getLoopDuration());const i=this._state.getAfter(s);i!==null&&(e=Math.min(e,i.time-s));e!==Infinity&&(e=new st(this.context,e));const o=new st(this.context,this._getLoopDuration());t.id=this.context.transport.scheduleRepeat(this._tick.bind(this),o,new st(this.context,s),e)}else t.id=this.context.transport.schedule(this._tick.bind(this),new st(this.context,s))}}))}get state(){return this._state.getValueAtTime(this.context.transport.ticks)}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t}get probability(){return this._probability}set probability(t){this._probability=t}get humanize(){return this._humanize}set humanize(t){this._humanize=t}
/**
     * Start the note at the given time.
     * @param  time  When the event should start.
     */start(t){const e=this.toTicks(t);if(this._state.getValueAtTime(e)==="stopped"){this._state.add({id:-1,state:"started",time:e});this._rescheduleEvents(e)}return this}
/**
     * Stop the Event at the given time.
     * @param  time  When the event should stop.
     */stop(t){this.cancel(t);const e=this.toTicks(t);if(this._state.getValueAtTime(e)==="started"){this._state.setStateAtTime("stopped",e,{id:-1});const t=this._state.getBefore(e);let s=e;t!==null&&(s=t.time);this._rescheduleEvents(s)}return this}
/**
     * Cancel all scheduled events greater than or equal to the given time
     * @param  time  The time after which events will be cancel.
     */cancel(t){t=w(t,-Infinity);const e=this.toTicks(t);this._state.forEachFrom(e,(t=>{this.context.transport.clear(t.id)}));this._state.cancel(e);return this}
/**
     * The callback function invoker. Also
     * checks if the Event is done playing
     * @param  time  The time of the event in seconds
     */_tick(t){const e=this.context.transport.getTicksAtTime(t);if(!this.mute&&this._state.getValueAtTime(e)==="started"){if(this.probability<1&&Math.random()>this.probability)return;if(this.humanize){let e=.02;L(this.humanize)||(e=this.toSeconds(this.humanize));t+=(Math.random()*2-1)*e}this.callback(t,this.value)}}_getLoopDuration(){return(this._loopEnd-this._loopStart)/this._playbackRate}get loop(){return this._loop}set loop(t){this._loop=t;this._rescheduleEvents()}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t;this._rescheduleEvents()}get loopEnd(){return new st(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t);this._loop&&this._rescheduleEvents()}get loopStart(){return new st(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t);this._loop&&this._rescheduleEvents()}get progress(){if(this._loop){const t=this.context.transport.ticks;const e=this._state.get(t);if(e!==null&&e.state==="started"){const s=this._getLoopDuration();const i=(t-e.time)%s;return i/s}return 0}return 0}dispose(){super.dispose();this.cancel();this._state.dispose();return this}}class Loop extends at{constructor(){const t=p(Loop.getDefaults(),arguments,["callback","interval"]);super(t);this.name="Loop";this._event=new ToneEvent({context:this.context,callback:this._tick.bind(this),loop:true,loopEnd:t.interval,playbackRate:t.playbackRate,probability:t.probability,humanize:t.humanize});this.callback=t.callback;this.iterations=t.iterations}static getDefaults(){return Object.assign(at.getDefaults(),{interval:"4n",callback:_,playbackRate:1,iterations:Infinity,probability:1,mute:false,humanize:false})}
/**
     * Start the loop at the specified time along the Transport's timeline.
     * @param  time  When to start the Loop.
     */start(t){this._event.start(t);return this}
/**
     * Stop the loop at the given time.
     * @param  time  When to stop the Loop.
     */stop(t){this._event.stop(t);return this}
/**
     * Cancel all scheduled events greater than or equal to the given time
     * @param  time  The time after which events will be cancel.
     */cancel(t){this._event.cancel(t);return this}
/**
     * Internal function called when the notes should be called
     * @param time  The time the event occurs
     */_tick(t){this.callback(t)}get state(){return this._event.state}get progress(){return this._event.progress}get interval(){return this._event.loopEnd}set interval(t){this._event.loopEnd=t}get playbackRate(){return this._event.playbackRate}set playbackRate(t){this._event.playbackRate=t}get humanize(){return this._event.humanize}set humanize(t){this._event.humanize=t}get probability(){return this._event.probability}set probability(t){this._event.probability=t}get mute(){return this._event.mute}set mute(t){this._event.mute=t}get iterations(){return this._event.loop===true?Infinity:this._event.loop}set iterations(t){this._event.loop=t===Infinity||t}dispose(){super.dispose();this._event.dispose();return this}}class Part extends ToneEvent{constructor(){const t=p(Part.getDefaults(),arguments,["callback","events"]);super(t);this.name="Part";this._state=new et("stopped");this._events=new Set;this._state.increasing=true;t.events.forEach((t=>{Q(t)?this.add(t[0],t[1]):this.add(t)}))}static getDefaults(){return Object.assign(ToneEvent.getDefaults(),{events:[]})}
/**
     * Start the part at the given time.
     * @param  time    When to start the part.
     * @param  offset  The offset from the start of the part to begin playing at.
     */start(t,e){const s=this.toTicks(t);if(this._state.getValueAtTime(s)!=="started"){e=w(e,this._loop?this._loopStart:0);e=this._loop?w(e,this._loopStart):w(e,0);const t=this.toTicks(e);this._state.add({id:-1,offset:t,state:"started",time:s});this._forEach((e=>{this._startNote(e,s,t)}))}return this}
/**
     * Start the event in the given event at the correct time given
     * the ticks and offset and looping.
     * @param  event
     * @param  ticks
     * @param  offset
     */_startNote(t,e,s){e-=s;if(this._loop){if(t.startOffset>=this._loopStart&&t.startOffset<this._loopEnd){t.startOffset<s&&(e+=this._getLoopDuration());t.start(new st(this.context,e))}else if(t.startOffset<this._loopStart&&t.startOffset>=s){t.loop=false;t.start(new st(this.context,e))}}else t.startOffset>=s&&t.start(new st(this.context,e))}get startOffset(){return this._startOffset}set startOffset(t){this._startOffset=t;this._forEach((t=>{t.startOffset+=this._startOffset}))}
/**
     * Stop the part at the given time.
     * @param  time  When to stop the part.
     */stop(t){const e=this.toTicks(t);this._state.cancel(e);this._state.setStateAtTime("stopped",e);this._forEach((e=>{e.stop(t)}));return this}
/**
     * Get/Set an Event's value at the given time.
     * If a value is passed in and no event exists at
     * the given time, one will be created with that value.
     * If two events are at the same time, the first one will
     * be returned.
     * @example
     * const part = new Tone.Part();
     * part.at("1m"); // returns the part at the first measure
     * part.at("2m", "C2"); // set the value at "2m" to C2.
     * // if an event didn't exist at that time, it will be created.
     * @param time The time of the event to get or set.
     * @param value If a value is passed in, the value of the event at the given time will be set to it.
     */at(t,e){const s=new ht(this.context,t).toTicks();const i=new st(this.context,1).toSeconds();const o=this._events.values();let n=o.next();while(!n.done){const t=n.value;if(Math.abs(s-t.startOffset)<i){H(e)&&(t.value=e);return t}n=o.next()}if(H(e)){this.add(t,e);return this.at(t)}return null}add(t,e){if(t instanceof Object&&Reflect.has(t,"time")){e=t;t=e.time}const s=this.toTicks(t);let i;if(e instanceof ToneEvent){i=e;i.callback=this._tick.bind(this)}else i=new ToneEvent({callback:this._tick.bind(this),context:this.context,value:e});i.startOffset=s;i.set({humanize:this.humanize,loop:this.loop,loopEnd:this.loopEnd,loopStart:this.loopStart,playbackRate:this.playbackRate,probability:this.probability});this._events.add(i);this._restartEvent(i);return this}_restartEvent(t){this._state.forEach((e=>{e.state==="started"?this._startNote(t,e.time,e.offset):t.stop(new st(this.context,e.time))}))}remove(t,e){if(U(t)&&t.hasOwnProperty("time")){e=t;t=e.time}t=this.toTicks(t);this._events.forEach((s=>{if(s.startOffset===t&&(W(e)||H(e)&&s.value===e)){this._events.delete(s);s.dispose()}}));return this}clear(){this._forEach((t=>t.dispose()));this._events.clear();return this}
/**
     * Cancel scheduled state change events: i.e. "start" and "stop".
     * @param after The time after which to cancel the scheduled events.
     */cancel(t){this._forEach((e=>e.cancel(t)));this._state.cancel(this.toTicks(t));return this}_forEach(t){this._events&&this._events.forEach((e=>{e instanceof Part?e._forEach(t):t(e)}));return this}
/**
     * Set the attribute of all of the events
     * @param  attr  the attribute to set
     * @param  value      The value to set it to
     */_setAll(t,e){this._forEach((s=>{s[t]=e}))}
/**
     * Internal tick method
     * @param  time  The time of the event in seconds
     */_tick(t,e){this.mute||this.callback(t,e)}
/**
     * Determine if the event should be currently looping
     * given the loop boundries of this Part.
     * @param  event  The event to test
     */_testLoopBoundries(t){this._loop&&(t.startOffset<this._loopStart||t.startOffset>=this._loopEnd)?t.cancel(0):t.state==="stopped"&&this._restartEvent(t)}get probability(){return this._probability}set probability(t){this._probability=t;this._setAll("probability",t)}get humanize(){return this._humanize}set humanize(t){this._humanize=t;this._setAll("humanize",t)}get loop(){return this._loop}set loop(t){this._loop=t;this._forEach((e=>{e.loopStart=this.loopStart;e.loopEnd=this.loopEnd;e.loop=t;this._testLoopBoundries(e)}))}get loopEnd(){return new st(this.context,this._loopEnd).toSeconds()}set loopEnd(t){this._loopEnd=this.toTicks(t);this._loop&&this._forEach((e=>{e.loopEnd=t;this._testLoopBoundries(e)}))}get loopStart(){return new st(this.context,this._loopStart).toSeconds()}set loopStart(t){this._loopStart=this.toTicks(t);this._loop&&this._forEach((t=>{t.loopStart=this.loopStart;this._testLoopBoundries(t)}))}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t;this._setAll("playbackRate",t)}get length(){return this._events.size}dispose(){super.dispose();this.clear();return this}}function*upPatternGen(t){let e=0;while(e<t){e=J(e,0,t-1);yield e;e++}}function*downPatternGen(t){let e=t-1;while(e>=0){e=J(e,0,t-1);yield e;e--}}function*infiniteGen(t,e){while(true)yield*e(t)}function*alternatingGenerator(t,e){let s=e?0:t-1;while(true){s=J(s,0,t-1);yield s;if(e){s++;s>=t-1&&(e=false)}else{s--;s<=0&&(e=true)}}}function*jumpUp(t){let e=0;let s=0;while(e<t){e=J(e,0,t-1);yield e;s++;e+=s%2?2:-1}}function*jumpDown(t){let e=t-1;let s=0;while(e>=0){e=J(e,0,t-1);yield e;s++;e+=s%2?-2:1}}function*randomGen(t){while(true){const e=Math.floor(Math.random()*t);yield e}}function*randomOnce(t){const e=[];for(let s=0;s<t;s++)e.push(s);while(e.length>0){const s=e.splice(Math.floor(e.length*Math.random()),1);const i=J(s[0],0,t-1);yield i}}function*randomWalk(t){let e=Math.floor(Math.random()*t);while(true){e===0?e++:e===t-1||Math.random()<.5?e--:e++;yield e}}
/**
 * PatternGenerator returns a generator which will yield numbers between 0 and numValues
 * according to the passed in pattern that can be used as indexes into an array of size numValues.
 * @param numValues The size of the array to emit indexes for
 * @param pattern The name of the pattern use when iterating over
 * @param index Where to start in the offset of the values array
 */function*PatternGenerator(t,e="up",s=0){v(t>=1,"The number of values must be at least one");switch(e){case"up":yield*infiniteGen(t,upPatternGen);case"down":yield*infiniteGen(t,downPatternGen);case"upDown":yield*alternatingGenerator(t,true);case"downUp":yield*alternatingGenerator(t,false);case"alternateUp":yield*infiniteGen(t,jumpUp);case"alternateDown":yield*infiniteGen(t,jumpDown);case"random":yield*randomGen(t);case"randomOnce":yield*infiniteGen(t,randomOnce);case"randomWalk":yield*randomWalk(t)}}class Pattern extends Loop{constructor(){const t=p(Pattern.getDefaults(),arguments,["callback","values","pattern"]);super(t);this.name="Pattern";this.callback=t.callback;this._values=t.values;this._pattern=PatternGenerator(t.values.length,t.pattern);this._type=t.pattern}static getDefaults(){return Object.assign(Loop.getDefaults(),{pattern:"up",values:[],callback:_})}_tick(t){const e=this._pattern.next();this._index=e.value;this._value=this._values[e.value];this.callback(t,this._value)}get values(){return this._values}set values(t){this._values=t;this.pattern=this._type}get value(){return this._value}get index(){return this._index}get pattern(){return this._type}set pattern(t){this._type=t;this._pattern=PatternGenerator(this._values.length,this._type)}}class Sequence extends ToneEvent{constructor(){const t=p(Sequence.getDefaults(),arguments,["callback","events","subdivision"]);super(t);this.name="Sequence";this._part=new Part({callback:this._seqCallback.bind(this),context:this.context});this._events=[];this._eventsArray=[];this._subdivision=this.toTicks(t.subdivision);this.events=t.events;this.loop=t.loop;this.loopStart=t.loopStart;this.loopEnd=t.loopEnd;this.playbackRate=t.playbackRate;this.probability=t.probability;this.humanize=t.humanize;this.mute=t.mute;this.playbackRate=t.playbackRate}static getDefaults(){return Object.assign(q(ToneEvent.getDefaults(),["value"]),{events:[],loop:true,loopEnd:0,loopStart:0,subdivision:"8n"})}_seqCallback(t,e){e===null||this.mute||this.callback(t,e)}get events(){return this._events}set events(t){this.clear();this._eventsArray=t;this._events=this._createSequence(this._eventsArray);this._eventsUpdated()}
/**
     * Start the part at the given time.
     * @param  time    When to start the part.
     * @param  offset  The offset index to start at
     */start(t,e){this._part.start(t,e?this._indexTime(e):e);return this}
/**
     * Stop the part at the given time.
     * @param  time  When to stop the part.
     */stop(t){this._part.stop(t);return this}get subdivision(){return new st(this.context,this._subdivision).toSeconds()}_createSequence(t){return new Proxy(t,{get:(t,e)=>t[e],set:(t,e,s)=>{$(e)&&isFinite(parseInt(e,10))&&Q(s)?t[e]=this._createSequence(s):t[e]=s;this._eventsUpdated();return true}})}_eventsUpdated(){this._part.clear();this._rescheduleSequence(this._eventsArray,this._subdivision,this.startOffset);this.loopEnd=this.loopEnd}_rescheduleSequence(t,e,s){t.forEach(((t,i)=>{const o=i*e+s;if(Q(t))this._rescheduleSequence(t,e/t.length,o);else{const e=new st(this.context,o,"i").toSeconds();this._part.add(e,t)}}))}
/**
     * Get the time of the index given the Sequence's subdivision
     * @param  index
     * @return The time of that index
     */_indexTime(t){return new st(this.context,t*this._subdivision+this.startOffset).toSeconds()}clear(){this._part.clear();return this}dispose(){super.dispose();this._part.dispose();return this}get loop(){return this._part.loop}set loop(t){this._part.loop=t}get loopStart(){return this._loopStart}set loopStart(t){this._loopStart=t;this._part.loopStart=this._indexTime(t)}get loopEnd(){return this._loopEnd}set loopEnd(t){this._loopEnd=t;this._part.loopEnd=t===0?this._indexTime(this._eventsArray.length):this._indexTime(t)}get startOffset(){return this._part.startOffset}set startOffset(t){this._part.startOffset=t}get playbackRate(){return this._part.playbackRate}set playbackRate(t){this._part.playbackRate=t}get probability(){return this._part.probability}set probability(t){this._part.probability=t}get progress(){return this._part.progress}get humanize(){return this._part.humanize}set humanize(t){this._part.humanize=t}get length(){return this._part.length}}class Panner extends rt{constructor(){const t=p(Panner.getDefaults(),arguments,["pan"]);super(t);this.name="Panner";this._panner=this.context.createStereoPanner();this.input=this._panner;this.output=this._panner;this.pan=new lt({context:this.context,param:this._panner.pan,value:t.pan,minValue:-1,maxValue:1});this._panner.channelCount=t.channelCount;this._panner.channelCountMode="explicit";m(this,"pan")}static getDefaults(){return Object.assign(rt.getDefaults(),{pan:0,channelCount:1})}dispose(){super.dispose();this._panner.disconnect();this.pan.dispose();return this}}class AutoPanner extends Ht{constructor(){const t=p(AutoPanner.getDefaults(),arguments,["frequency"]);super(t);this.name="AutoPanner";this._panner=new Panner({context:this.context,channelCount:t.channelCount});this.connectEffect(this._panner);this._lfo.connect(this._panner.pan);this._lfo.min=-1;this._lfo.max=1}static getDefaults(){return Object.assign(Ht.getDefaults(),{channelCount:1})}dispose(){super.dispose();this._panner.dispose();return this}}const te=[1557/44100,1617/44100,1491/44100,1422/44100,1277/44100,1356/44100,1188/44100,1116/44100];const ee=[225,556,441,341];class Freeverb extends Ut{constructor(){const t=p(Freeverb.getDefaults(),arguments,["roomSize","dampening"]);super(t);this.name="Freeverb";this._combFilters=[];this._allpassFiltersL=[];this._allpassFiltersR=[];this.roomSize=new jt({context:this.context,value:t.roomSize,units:"normalRange"});this._allpassFiltersL=ee.map((t=>{const e=this.context.createBiquadFilter();e.type="allpass";e.frequency.value=t;return e}));this._allpassFiltersR=ee.map((t=>{const e=this.context.createBiquadFilter();e.type="allpass";e.frequency.value=t;return e}));this._combFilters=te.map(((e,s)=>{const i=new LowpassCombFilter({context:this.context,dampening:t.dampening,delayTime:e});s<te.length/2?this.connectEffectLeft(i,...this._allpassFiltersL):this.connectEffectRight(i,...this._allpassFiltersR);this.roomSize.connect(i.resonance);return i}));m(this,["roomSize"])}static getDefaults(){return Object.assign(Ut.getDefaults(),{roomSize:.7,dampening:3e3})}get dampening(){return this._combFilters[0].dampening}set dampening(t){this._combFilters.forEach((e=>e.dampening=t))}dispose(){super.dispose();this._allpassFiltersL.forEach((t=>t.disconnect()));this._allpassFiltersR.forEach((t=>t.disconnect()));this._combFilters.forEach((t=>t.dispose()));this.roomSize.dispose();return this}}const se=[.06748,.06404,.08212,.09004];const ie=[.773,.802,.753,.733];const oe=[347,113,37];class JCReverb extends Ut{constructor(){const t=p(JCReverb.getDefaults(),arguments,["roomSize"]);super(t);this.name="JCReverb";this._allpassFilters=[];this._feedbackCombFilters=[];this.roomSize=new jt({context:this.context,value:t.roomSize,units:"normalRange"});this._scaleRoomSize=new Ct({context:this.context,min:-.733,max:.197});this._allpassFilters=oe.map((t=>{const e=this.context.createBiquadFilter();e.type="allpass";e.frequency.value=t;return e}));this._feedbackCombFilters=se.map(((t,e)=>{const s=new FeedbackCombFilter({context:this.context,delayTime:t});this._scaleRoomSize.connect(s.resonance);s.resonance.value=ie[e];e<se.length/2?this.connectEffectLeft(...this._allpassFilters,s):this.connectEffectRight(...this._allpassFilters,s);return s}));this.roomSize.connect(this._scaleRoomSize);m(this,["roomSize"])}static getDefaults(){return Object.assign(Ut.getDefaults(),{roomSize:.5})}dispose(){super.dispose();this._allpassFilters.forEach((t=>t.disconnect()));this._feedbackCombFilters.forEach((t=>t.dispose()));this.roomSize.dispose();this._scaleRoomSize.dispose();return this}}class DCMeter extends Wt{constructor(){super(p(DCMeter.getDefaults(),arguments));this.name="DCMeter";this._analyser.type="waveform";this._analyser.size=256}getValue(){const t=this._analyser.getValue();return t[0]}}class Solo extends rt{constructor(){const t=p(Solo.getDefaults(),arguments,["solo"]);super(t);this.name="Solo";this.input=this.output=new it({context:this.context});Solo._allSolos.has(this.context)||Solo._allSolos.set(this.context,new Set);Solo._allSolos.get(this.context).add(this);this.solo=t.solo}static getDefaults(){return Object.assign(rt.getDefaults(),{solo:false})}get solo(){return this._isSoloed()}set solo(t){t?this._addSolo():this._removeSolo();Solo._allSolos.get(this.context).forEach((t=>t._updateSolo()))}get muted(){return this.input.gain.value===0}_addSolo(){Solo._soloed.has(this.context)||Solo._soloed.set(this.context,new Set);Solo._soloed.get(this.context).add(this)}_removeSolo(){Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).delete(this)}_isSoloed(){return Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).has(this)}_noSolos(){return!Solo._soloed.has(this.context)||Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).size===0}_updateSolo(){this._isSoloed()||this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){super.dispose();Solo._allSolos.get(this.context).delete(this);this._removeSolo();return this}}Solo._allSolos=new Map;Solo._soloed=new Map;class PanVol extends rt{constructor(){const t=p(PanVol.getDefaults(),arguments,["pan","volume"]);super(t);this.name="PanVol";this._panner=this.input=new Panner({context:this.context,pan:t.pan,channelCount:t.channelCount});this.pan=this._panner.pan;this._volume=this.output=new St({context:this.context,volume:t.volume});this.volume=this._volume.volume;this._panner.connect(this._volume);this.mute=t.mute;m(this,["pan","volume"])}static getDefaults(){return Object.assign(rt.getDefaults(),{mute:false,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(t){this._volume.mute=t}dispose(){super.dispose();this._panner.dispose();this.pan.dispose();this._volume.dispose();this.volume.dispose();return this}}class Channel extends rt{constructor(){const t=p(Channel.getDefaults(),arguments,["volume","pan"]);super(t);this.name="Channel";this._solo=this.input=new Solo({solo:t.solo,context:this.context});this._panVol=this.output=new PanVol({context:this.context,pan:t.pan,volume:t.volume,mute:t.mute,channelCount:t.channelCount});this.pan=this._panVol.pan;this.volume=this._panVol.volume;this._solo.connect(this._panVol);m(this,["pan","volume"])}static getDefaults(){return Object.assign(rt.getDefaults(),{pan:0,volume:0,mute:false,solo:false,channelCount:1})}get solo(){return this._solo.solo}set solo(t){this._solo.solo=t}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(t){this._panVol.mute=t}
/**
     * Get the gain node belonging to the bus name. Create it if
     * it doesn't exist
     * @param name The bus name
     */_getBus(t){Channel.buses.has(t)||Channel.buses.set(t,new it({context:this.context}));return Channel.buses.get(t)}
/**
     * Send audio to another channel using a string. `send` is a lot like
     * {@link connect}, except it uses a string instead of an object. This can
     * be useful in large applications to decouple sections since {@link send}
     * and {@link receive} can be invoked separately in order to connect an object
     * @param name The channel name to send the audio
     * @param volume The amount of the signal to send.
     * 	Defaults to 0db, i.e. send the entire signal
     * @returns Returns the gain node of this connection.
     */send(t,e=0){const s=this._getBus(t);const i=new it({context:this.context,units:"decibels",gain:e});this.connect(i);i.connect(s);return i}
/**
     * Receive audio from a channel which was connected with {@link send}.
     * @param name The channel name to receive audio from.
     */receive(t){const e=this._getBus(t);e.connect(this);return this}dispose(){super.dispose();this._panVol.dispose();this.pan.dispose();this.volume.dispose();this._solo.dispose();return this}}Channel.buses=new Map;class Mono extends rt{constructor(){super(p(Mono.getDefaults(),arguments));this.name="Mono";this.input=new it({context:this.context});this._merge=this.output=new Zt({channels:2,context:this.context});this.input.connect(this._merge,0,0);this.input.connect(this._merge,0,1)}dispose(){super.dispose();this._merge.dispose();this.input.dispose();return this}}class MultibandSplit extends rt{constructor(){const t=p(MultibandSplit.getDefaults(),arguments,["lowFrequency","highFrequency"]);super(t);this.name="MultibandSplit";this.input=new it({context:this.context});this.output=void 0;this.low=new Vt({context:this.context,frequency:0,type:"lowpass"});this._lowMidFilter=new Vt({context:this.context,frequency:0,type:"highpass"});this.mid=new Vt({context:this.context,frequency:0,type:"lowpass"});this.high=new Vt({context:this.context,frequency:0,type:"highpass"});this._internalChannels=[this.low,this.mid,this.high];this.lowFrequency=new jt({context:this.context,units:"frequency",value:t.lowFrequency});this.highFrequency=new jt({context:this.context,units:"frequency",value:t.highFrequency});this.Q=new jt({context:this.context,units:"positive",value:t.Q});this.input.fan(this.low,this.high);this.input.chain(this._lowMidFilter,this.mid);this.lowFrequency.fan(this.low.frequency,this._lowMidFilter.frequency);this.highFrequency.fan(this.mid.frequency,this.high.frequency);this.Q.connect(this.low.Q);this.Q.connect(this._lowMidFilter.Q);this.Q.connect(this.mid.Q);this.Q.connect(this.high.Q);m(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(rt.getDefaults(),{Q:1,highFrequency:2500,lowFrequency:400})}dispose(){super.dispose();K(this,["high","mid","low","highFrequency","lowFrequency"]);this.low.dispose();this._lowMidFilter.dispose();this.mid.dispose();this.high.dispose();this.lowFrequency.dispose();this.highFrequency.dispose();this.Q.dispose();return this}}class Recorder extends rt{constructor(){const t=p(Recorder.getDefaults(),arguments);super(t);this.name="Recorder";this.input=new it({context:this.context});v(Recorder.supported,"Media Recorder API is not available");this._stream=this.context.createMediaStreamDestination();this.input.connect(this._stream);this._recorder=new MediaRecorder(this._stream.stream,{mimeType:t.mimeType})}static getDefaults(){return rt.getDefaults()}get mimeType(){return this._recorder.mimeType}static get supported(){return X!==null&&Reflect.has(X,"MediaRecorder")}get state(){return this._recorder.state==="inactive"?"stopped":this._recorder.state==="paused"?"paused":"started"}start(){return ot(this,void 0,void 0,(function*(){v(this.state!=="started","Recorder is already started");const t=new Promise((t=>{const handleStart=()=>{this._recorder.removeEventListener("start",handleStart,false);t()};this._recorder.addEventListener("start",handleStart,false)}));this._recorder.start();return yield t}))}stop(){return ot(this,void 0,void 0,(function*(){v(this.state!=="stopped","Recorder is not started");const t=new Promise((t=>{const handleData=e=>{this._recorder.removeEventListener("dataavailable",handleData,false);t(e.data)};this._recorder.addEventListener("dataavailable",handleData,false)}));this._recorder.stop();return yield t}))}pause(){v(this.state==="started","Recorder must be started");this._recorder.pause();return this}dispose(){super.dispose();this.input.dispose();this._stream.disconnect();return this}}class Compressor extends rt{constructor(){const t=p(Compressor.getDefaults(),arguments,["threshold","ratio"]);super(t);this.name="Compressor";this._compressor=this.context.createDynamicsCompressor();this.input=this._compressor;this.output=this._compressor;this.threshold=new lt({minValue:this._compressor.threshold.minValue,maxValue:this._compressor.threshold.maxValue,context:this.context,convert:false,param:this._compressor.threshold,units:"decibels",value:t.threshold});this.attack=new lt({minValue:this._compressor.attack.minValue,maxValue:this._compressor.attack.maxValue,context:this.context,param:this._compressor.attack,units:"time",value:t.attack});this.release=new lt({minValue:this._compressor.release.minValue,maxValue:this._compressor.release.maxValue,context:this.context,param:this._compressor.release,units:"time",value:t.release});this.knee=new lt({minValue:this._compressor.knee.minValue,maxValue:this._compressor.knee.maxValue,context:this.context,convert:false,param:this._compressor.knee,units:"decibels",value:t.knee});this.ratio=new lt({minValue:this._compressor.ratio.minValue,maxValue:this._compressor.ratio.maxValue,context:this.context,convert:false,param:this._compressor.ratio,units:"positive",value:t.ratio});m(this,["knee","release","attack","ratio","threshold"])}static getDefaults(){return Object.assign(rt.getDefaults(),{attack:.003,knee:30,ratio:12,release:.25,threshold:-24})}get reduction(){return this._compressor.reduction}dispose(){super.dispose();this._compressor.disconnect();this.attack.dispose();this.release.dispose();this.threshold.dispose();this.ratio.dispose();this.knee.dispose();return this}}class Gate extends rt{constructor(){const t=p(Gate.getDefaults(),arguments,["threshold","smoothing"]);super(t);this.name="Gate";this._follower=new kt({context:this.context,smoothing:t.smoothing});this._gt=new GreaterThan({context:this.context,value:mt(t.threshold)});this.input=new it({context:this.context});this._gate=this.output=new it({context:this.context});this.input.connect(this._gate);this.input.chain(this._follower,this._gt,this._gate.gain)}static getDefaults(){return Object.assign(rt.getDefaults(),{smoothing:.1,threshold:-40})}get threshold(){return _t(this._gt.value)}set threshold(t){this._gt.value=mt(t)}get smoothing(){return this._follower.smoothing}set smoothing(t){this._follower.smoothing=t}dispose(){super.dispose();this.input.dispose();this._follower.dispose();this._gt.dispose();this._gate.dispose();return this}}class Limiter extends rt{constructor(){const t=p(Limiter.getDefaults(),arguments,["threshold"]);super(t);this.name="Limiter";this._compressor=this.input=this.output=new Compressor({context:this.context,ratio:20,attack:.003,release:.01,threshold:t.threshold});this.threshold=this._compressor.threshold;m(this,"threshold")}static getDefaults(){return Object.assign(rt.getDefaults(),{threshold:-12})}get reduction(){return this._compressor.reduction}dispose(){super.dispose();this._compressor.dispose();this.threshold.dispose();return this}}class MidSideCompressor extends rt{constructor(){const t=p(MidSideCompressor.getDefaults(),arguments);super(t);this.name="MidSideCompressor";this._midSideSplit=this.input=new Tt({context:this.context});this._midSideMerge=this.output=new Ft({context:this.context});this.mid=new Compressor(Object.assign(t.mid,{context:this.context}));this.side=new Compressor(Object.assign(t.side,{context:this.context}));this._midSideSplit.mid.chain(this.mid,this._midSideMerge.mid);this._midSideSplit.side.chain(this.side,this._midSideMerge.side);m(this,["mid","side"])}static getDefaults(){return Object.assign(rt.getDefaults(),{mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},side:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10}})}dispose(){super.dispose();this.mid.dispose();this.side.dispose();this._midSideSplit.dispose();this._midSideMerge.dispose();return this}}class MultibandCompressor extends rt{constructor(){const t=p(MultibandCompressor.getDefaults(),arguments);super(t);this.name="MultibandCompressor";this._splitter=this.input=new MultibandSplit({context:this.context,lowFrequency:t.lowFrequency,highFrequency:t.highFrequency});this.lowFrequency=this._splitter.lowFrequency;this.highFrequency=this._splitter.highFrequency;this.output=new it({context:this.context});this.low=new Compressor(Object.assign(t.low,{context:this.context}));this.mid=new Compressor(Object.assign(t.mid,{context:this.context}));this.high=new Compressor(Object.assign(t.high,{context:this.context}));this._splitter.low.chain(this.low,this.output);this._splitter.mid.chain(this.mid,this.output);this._splitter.high.chain(this.high,this.output);m(this,["high","mid","low","highFrequency","lowFrequency"])}static getDefaults(){return Object.assign(rt.getDefaults(),{lowFrequency:250,highFrequency:2e3,low:{ratio:6,threshold:-30,release:.25,attack:.03,knee:10},mid:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16},high:{ratio:3,threshold:-24,release:.03,attack:.02,knee:16}})}dispose(){super.dispose();this._splitter.dispose();this.low.dispose();this.mid.dispose();this.high.dispose();this.output.dispose();return this}}class EQ3 extends rt{constructor(){const t=p(EQ3.getDefaults(),arguments,["low","mid","high"]);super(t);this.name="EQ3";this.output=new it({context:this.context});this._internalChannels=[];this.input=this._multibandSplit=new MultibandSplit({context:this.context,highFrequency:t.highFrequency,lowFrequency:t.lowFrequency});this._lowGain=new it({context:this.context,gain:t.low,units:"decibels"});this._midGain=new it({context:this.context,gain:t.mid,units:"decibels"});this._highGain=new it({context:this.context,gain:t.high,units:"decibels"});this.low=this._lowGain.gain;this.mid=this._midGain.gain;this.high=this._highGain.gain;this.Q=this._multibandSplit.Q;this.lowFrequency=this._multibandSplit.lowFrequency;this.highFrequency=this._multibandSplit.highFrequency;this._multibandSplit.low.chain(this._lowGain,this.output);this._multibandSplit.mid.chain(this._midGain,this.output);this._multibandSplit.high.chain(this._highGain,this.output);m(this,["low","mid","high","lowFrequency","highFrequency"]);this._internalChannels=[this._multibandSplit]}static getDefaults(){return Object.assign(rt.getDefaults(),{high:0,highFrequency:2500,low:0,lowFrequency:400,mid:0})}dispose(){super.dispose();K(this,["low","mid","high","lowFrequency","highFrequency"]);this._multibandSplit.dispose();this.lowFrequency.dispose();this.highFrequency.dispose();this._lowGain.dispose();this._midGain.dispose();this._highGain.dispose();this.low.dispose();this.mid.dispose();this.high.dispose();this.Q.dispose();return this}}class Convolver extends rt{constructor(){const t=p(Convolver.getDefaults(),arguments,["url","onload"]);super(t);this.name="Convolver";this._convolver=this.context.createConvolver();this._buffer=new n(t.url,(e=>{this.buffer=e;t.onload()}));this.input=new it({context:this.context});this.output=new it({context:this.context});this._buffer.loaded&&(this.buffer=this._buffer);this.normalize=t.normalize;this.input.chain(this._convolver,this.output)}static getDefaults(){return Object.assign(rt.getDefaults(),{normalize:true,onload:_})}
/**
     * Load an impulse response url as an audio buffer.
     * Decodes the audio asynchronously and invokes
     * the callback once the audio buffer loads.
     * @param url The url of the buffer to load. filetype support depends on the browser.
     */load(t){return ot(this,void 0,void 0,(function*(){this.buffer=yield this._buffer.load(t)}))}get buffer(){return this._buffer.length?this._buffer:null}set buffer(t){t&&this._buffer.set(t);if(this._convolver.buffer){this.input.disconnect();this._convolver.disconnect();this._convolver=this.context.createConvolver();this.input.chain(this._convolver,this.output)}const e=this._buffer.get();this._convolver.buffer=e||null}get normalize(){return this._convolver.normalize}set normalize(t){this._convolver.normalize=t}dispose(){super.dispose();this._buffer.dispose();this._convolver.disconnect();return this}}function now(){return t().now()}function immediate(){return t().immediate()}
/**
 * The Transport object belonging to the global Tone.js Context.
 * @see {@link TransportClass}
 * @category Core
 * @deprecated Use {@link getTransport} instead
 */const ne=t().transport;function getTransport(){return t().transport}
/**
 * The Destination (output) belonging to the global Tone.js Context.
 * @see {@link DestinationClass}
 * @category Core
 * @deprecated Use {@link getDestination} instead
 */const ae=t().destination;
/**
 * @deprecated Use {@link getDestination} instead
 */const re=t().destination;function getDestination(){return t().destination}
/**
 * The {@link ListenerClass} belonging to the global Tone.js Context.
 * @category Core
 * @deprecated Use {@link getListener} instead
 */const he=t().listener;function getListener(){return t().listener}
/**
 * Draw is used to synchronize the draw frame with the Transport's callbacks.
 * @see {@link DrawClass}
 * @category Core
 * @deprecated Use {@link getDraw} instead
 */const ce=t().draw;function getDraw(){return t().draw}
/**
 * A reference to the global context
 * @see {@link Context}
 * @deprecated Use {@link getContext} instead
 */const le=t();function loaded(){return n.loaded()}
/** @deprecated Use {@link ToneAudioBuffer} */const ue=n;
/** @deprecated Use {@link ToneAudioBuffers} */const pe=pt;
/** @deprecated Use {@link ToneBufferSource} */const de=yt;export{zt as AmplitudeEnvelope,AutoPanner,ue as Buffer,de as BufferSource,pe as Buffers,Channel,tt as Clock,Compressor,Convolver,DCMeter,ae as Destination,ce as Draw,DuoSynth,EQ3,Mt as Envelope,vt as FMOscillator,FeedbackCombFilter,Vt as Filter,kt as Follower,Freeverb,ct as FrequencyClass,it as Gain,Gate,GrainPlayer,GreaterThan,GreaterThanZero,JCReverb,bt as LFO,Limiter,he as Listener,Loop,LowpassCombFilter,re as Master,MembraneSynth,Zt as Merge,MetalSynth,MidSideCompressor,Ft as MidSideMerge,Tt as MidSideSplit,Mono,At as MonoSynth,MultibandCompressor,MultibandSplit,Ot as Multiply,ft as Noise,NoiseSynth,Offline,s as OfflineContext,wt as OnePoleFilter,PanVol,Panner,lt as Param,Part,Pattern,xt as Player,Players,PluckSynth,Recorder,Ct as Scale,Sequence,jt as Signal,Solo,et as StateTimeline,Dt as Subtract,SyncedSignal,Pt as Synth,st as TicksClass,r as Timeline,n as ToneAudioBuffer,pt as ToneAudioBuffers,rt as ToneAudioNode,yt as ToneBufferSource,ToneEvent,ne as Transport,ht as TransportTimeClass,Jt as Unit,St as Volume,Rt as WaveShaper,ut as connectSeries,le as context,mt as dbToGain,w as defaultArg,_t as gainToDb,t as getContext,getDestination,getDraw,getListener,getTransport,immediate,dt as intervalToFrequencyRatio,Q as isArray,L as isBoolean,H as isDefined,V as isNumber,U as isObject,$ as isString,W as isUndef,loaded,now,p as optionsFromArguments,o as setContext};

