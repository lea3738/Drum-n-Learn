// standardized-audio-context@25.3.77 downloaded from https://ga.jspm.io/npm:standardized-audio-context@25.3.77/build/es2019/module.js

import{AutomationEventList as e,createCancelAndHoldAutomationEvent as t,createCancelScheduledValuesAutomationEvent as n,createExponentialRampToValueAutomationEvent as o,createLinearRampToValueAutomationEvent as r,createSetTargetAutomationEvent as s,createSetValueAutomationEvent as a,createSetValueCurveAutomationEvent as c}from"automation-events";const createAbortError=()=>new DOMException("","AbortError");const createAddActiveInputConnectionToAudioNode=e=>(t,n,[o,r,s],a)=>{e(t[r],[n,o,s],(e=>e[0]===n&&e[1]===o),a)};const createAddAudioNodeConnections=e=>(t,n,o)=>{const r=[];for(let e=0;e<o.numberOfInputs;e+=1)r.push(new Set);e.set(t,{activeInputs:r,outputs:new Set,passiveInputs:new WeakMap,renderer:n})};const createAddAudioParamConnections=e=>(t,n)=>{e.set(t,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:n})};const i=new WeakSet;const l=new WeakMap;const u=new WeakMap;const d=new WeakMap;const h=new WeakMap;const f=new WeakMap;const p=new WeakMap;const m=new WeakMap;const v=new WeakMap;const g=new WeakMap;const C={construct(){return C}};const isConstructible=e=>{try{const t=new Proxy(e,C);new t}catch{return false}return true};const w=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;const splitImportStatements=(e,t)=>{const n=[];let o=e.replace(/^[\s]+/,"");let r=o.match(w);while(r!==null){const e=r[1].slice(1,-1);const s=r[0].replace(/([\s]+)?;?$/,"").replace(e,new URL(e,t).toString());n.push(s);o=o.slice(r[0].length).replace(/^[\s]+/,"");r=o.match(w)}return[n.join(";"),o]};const verifyParameterDescriptors=e=>{if(e!==void 0&&!Array.isArray(e))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")};const verifyProcessorCtor=e=>{if(!isConstructible(e))throw new TypeError("The given value for processorCtor should be a constructor.");if(e.prototype===null||typeof e.prototype!=="object")throw new TypeError("The given value for processorCtor should have a prototype.")};const createAddAudioWorkletModule=(e,t,n,o,r,s,a,c,i,l,u,d,h)=>{let f=0;return(p,m,g={credentials:"omit"})=>{const C=u.get(p);if(C!==void 0&&C.has(m))return Promise.resolve();const w=l.get(p);if(w!==void 0){const e=w.get(m);if(e!==void 0)return e}const y=s(p);const _=y.audioWorklet===void 0?r(m).then((([e,t])=>{const[o,r]=splitImportStatements(e,t);const s=`${o};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${r}\n})})(window,'_AWGS')`;return n(s)})).then((()=>{const e=h._AWGS.pop();if(e===void 0)throw new SyntaxError;o(y.currentTime,y.sampleRate,(()=>e(class AudioWorkletProcessor{},void 0,((e,n)=>{if(e.trim()==="")throw t();const o=v.get(y);if(o!==void 0){if(o.has(e))throw t();verifyProcessorCtor(n);verifyParameterDescriptors(n.parameterDescriptors);o.set(e,n)}else{verifyProcessorCtor(n);verifyParameterDescriptors(n.parameterDescriptors);v.set(y,new Map([[e,n]]))}}),y.sampleRate,void 0,void 0)))})):Promise.all([r(m),Promise.resolve(e(d,d))]).then((([[e,t],n])=>{const o=f+1;f=o;const[r,s]=splitImportStatements(e,t);const l=n?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";const u=n?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";const d=n?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";const h=`${r};((AudioWorkletProcessor,registerProcessor)=>{${s}\n})(${l},(n,p)=>registerProcessor(n,class extends p{${u}process(i,o,p){${d}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${o}',class extends AudioWorkletProcessor{process(){return !1}})`;const p=new Blob([h],{type:"application/javascript; charset=utf-8"});const m=URL.createObjectURL(p);return y.audioWorklet.addModule(m,g).then((()=>{if(c(y))return y;const e=a(y);return e.audioWorklet.addModule(m,g).then((()=>e))})).then((e=>{if(i===null)throw new SyntaxError;try{new i(e,`__sac${o}`)}catch{throw new SyntaxError}})).finally((()=>URL.revokeObjectURL(m)))}));w===void 0?l.set(p,new Map([[m,_]])):w.set(m,_);_.then((()=>{const e=u.get(p);e===void 0?u.set(p,new Set([m])):e.add(m)})).finally((()=>{const e=l.get(p);e!==void 0&&e.delete(m)}));return _}};const getValueForKey=(e,t)=>{const n=e.get(t);if(n===void 0)throw new Error("A value with the given key could not be found.");return n};const pickElementFromSet=(e,t)=>{const n=Array.from(e).filter(t);if(n.length>1)throw Error("More than one element was found.");if(n.length===0)throw Error("No element was found.");const[o]=n;e.delete(o);return o};const deletePassiveInputConnectionToAudioNode=(e,t,n,o)=>{const r=getValueForKey(e,t);const s=pickElementFromSet(r,(e=>e[0]===n&&e[1]===o));r.size===0&&e.delete(t);return s};const getEventListenersOfAudioNode=e=>getValueForKey(p,e);const setInternalStateToActive=e=>{if(i.has(e))throw new Error("The AudioNode is already stored.");i.add(e);getEventListenersOfAudioNode(e).forEach((e=>e(true)))};const isAudioWorkletNode=e=>"port"in e;const setInternalStateToPassive=e=>{if(!i.has(e))throw new Error("The AudioNode is not stored.");i.delete(e);getEventListenersOfAudioNode(e).forEach((e=>e(false)))};const setInternalStateToPassiveWhenNecessary=(e,t)=>{!isAudioWorkletNode(e)&&t.every((e=>e.size===0))&&setInternalStateToPassive(e)};const createAddConnectionToAudioNode=(e,t,n,o,r,s,a,c,i,l,u,d,h)=>{const f=new WeakMap;return(p,m,v,g,C)=>{const{activeInputs:w,passiveInputs:y}=s(m);const{outputs:_}=s(p);const M=c(p);const eventListener=s=>{const c=i(m);const l=i(p);if(s){const t=deletePassiveInputConnectionToAudioNode(y,p,v,g);e(w,p,t,false);C||d(p)||n(l,c,v,g);h(m)&&setInternalStateToActive(m)}else{const e=o(w,p,v,g);t(y,g,e,false);C||d(p)||r(l,c,v,g);const n=a(m);if(n===0)u(m)&&setInternalStateToPassiveWhenNecessary(m,w);else{const e=f.get(m);e!==void 0&&clearTimeout(e);f.set(m,setTimeout((()=>{u(m)&&setInternalStateToPassiveWhenNecessary(m,w)}),n*1e3))}}};if(l(_,[m,v,g],(e=>e[0]===m&&e[1]===v&&e[2]===g),true)){M.add(eventListener);u(p)?e(w,p,[v,g,eventListener],true):t(y,g,[p,v,eventListener],true);return true}return false}};const createAddPassiveInputConnectionToAudioNode=e=>(t,n,[o,r,s],a)=>{const c=t.get(o);c===void 0?t.set(o,new Set([[r,n,s]])):e(c,[r,n,s],(e=>e[0]===r&&e[1]===n),a)};const createAddSilentConnection=e=>(t,n)=>{const o=e(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});n.connect(o).connect(t.destination);const disconnect=()=>{n.removeEventListener("ended",disconnect);n.disconnect(o);o.disconnect()};n.addEventListener("ended",disconnect)};const createAddUnrenderedAudioWorkletNode=e=>(t,n)=>{e(t).add(n)};const y={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8};const createAnalyserNodeConstructor=(e,t,n,o,r,s)=>class AnalyserNode extends e{constructor(e,n){const a=r(e);const c={...y,...n};const i=o(a,c);const l=s(a)?t():null;super(e,false,i,l);this._nativeAnalyserNode=i}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(e){this._nativeAnalyserNode.fftSize=e}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(e){const t=this._nativeAnalyserNode.maxDecibels;this._nativeAnalyserNode.maxDecibels=e;if(!(e>this._nativeAnalyserNode.minDecibels)){this._nativeAnalyserNode.maxDecibels=t;throw n()}}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(e){const t=this._nativeAnalyserNode.minDecibels;this._nativeAnalyserNode.minDecibels=e;if(!(this._nativeAnalyserNode.maxDecibels>e)){this._nativeAnalyserNode.minDecibels=t;throw n()}}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(e){this._nativeAnalyserNode.smoothingTimeConstant=e}getByteFrequencyData(e){this._nativeAnalyserNode.getByteFrequencyData(e)}getByteTimeDomainData(e){this._nativeAnalyserNode.getByteTimeDomainData(e)}getFloatFrequencyData(e){this._nativeAnalyserNode.getFloatFrequencyData(e)}getFloatTimeDomainData(e){this._nativeAnalyserNode.getFloatTimeDomainData(e)}};const isOwnedByContext=(e,t)=>e.context===t;const createAnalyserNodeRendererFactory=(e,t,n)=>()=>{const o=new WeakMap;const createAnalyserNode=async(r,s)=>{let a=t(r);const c=isOwnedByContext(a,s);if(!c){const t={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,fftSize:a.fftSize,maxDecibels:a.maxDecibels,minDecibels:a.minDecibels,smoothingTimeConstant:a.smoothingTimeConstant};a=e(s,t)}o.set(s,a);await n(r,s,a);return a};return{render(e,t){const n=o.get(t);return n!==void 0?Promise.resolve(n):createAnalyserNode(e,t)}}};const testAudioBufferCopyChannelMethodsOutOfBoundsSupport=e=>{try{e.copyToChannel(new Float32Array(1),0,-1)}catch{return false}return true};const createIndexSizeError=()=>new DOMException("","IndexSizeError");const wrapAudioBufferGetChannelDataMethod=e=>{e.getChannelData=(t=>n=>{try{return t.call(e,n)}catch(e){if(e.code===12)throw createIndexSizeError();throw e}})(e.getChannelData)};const _={numberOfChannels:1};const createAudioBufferConstructor=(e,t,n,o,r,s,a,c)=>{let i=null;return class AudioBuffer{constructor(l){if(r===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:u,numberOfChannels:d,sampleRate:h}={..._,...l};i===null&&(i=new r(1,1,44100));const f=o!==null&&t(s,s)?new o({length:u,numberOfChannels:d,sampleRate:h}):i.createBuffer(d,u,h);if(f.numberOfChannels===0)throw n();if(typeof f.copyFromChannel!=="function"){a(f);wrapAudioBufferGetChannelDataMethod(f)}else t(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,(()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(f)))||c(f);e.add(f);return f}static[Symbol.hasInstance](t){return t!==null&&typeof t==="object"&&Object.getPrototypeOf(t)===AudioBuffer.prototype||e.has(t)}}};const M=-34028234663852886e22;const b=-M;const isActiveAudioNode=e=>i.has(e);const A={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:false,loopEnd:0,loopStart:0,playbackRate:1};const createAudioBufferSourceNodeConstructor=(e,t,n,o,r,s,a,c)=>class AudioBufferSourceNode extends e{constructor(e,o){const c=s(e);const i={...A,...o};const l=r(c,i);const u=a(c);const d=u?t():null;super(e,false,l,d);this._audioBufferSourceNodeRenderer=d;this._isBufferNullified=false;this._isBufferSet=i.buffer!==null;this._nativeAudioBufferSourceNode=l;this._onended=null;this._playbackRate=n(this,u,l.playbackRate,b,M)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(e){this._nativeAudioBufferSourceNode.buffer=e;if(e!==null){if(this._isBufferSet)throw o();this._isBufferSet=true}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(e){this._nativeAudioBufferSourceNode.loop=e}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(e){this._nativeAudioBufferSourceNode.loopEnd=e}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(e){this._nativeAudioBufferSourceNode.loopStart=e}get onended(){return this._onended}set onended(e){const t=typeof e==="function"?c(this,e):null;this._nativeAudioBufferSourceNode.onended=t;const n=this._nativeAudioBufferSourceNode.onended;this._onended=n!==null&&n===t?e:n}get playbackRate(){return this._playbackRate}start(e=0,t=0,n){this._nativeAudioBufferSourceNode.start(e,t,n);this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=n===void 0?[e,t]:[e,t,n]);if(this.context.state!=="closed"){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",resetInternalStateToPassive);isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",resetInternalStateToPassive)}}stop(e=0){this._nativeAudioBufferSourceNode.stop(e);this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=e)}};const createAudioBufferSourceNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;let a=null;let c=null;const createAudioBufferSourceNode=async(i,l)=>{let u=n(i);const d=isOwnedByContext(u,l);if(!d){const e={buffer:u.buffer,channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,loop:u.loop,loopEnd:u.loopEnd,loopStart:u.loopStart,playbackRate:u.playbackRate.value};u=t(l,e);a!==null&&u.start(...a);c!==null&&u.stop(c)}s.set(l,u);d?await e(l,i.playbackRate,u.playbackRate):await o(l,i.playbackRate,u.playbackRate);await r(i,l,u);return u};return{set start(e){a=e},set stop(e){c=e},render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createAudioBufferSourceNode(e,t)}}};const isAudioBufferSourceNode=e=>"playbackRate"in e;const isBiquadFilterNode=e=>"frequency"in e&&"gain"in e;const isConstantSourceNode=e=>"offset"in e;const isGainNode=e=>!("frequency"in e)&&"gain"in e;const isOscillatorNode=e=>"detune"in e&&"frequency"in e&&!("gain"in e);const isStereoPannerNode=e=>"pan"in e;const getAudioNodeConnections=e=>getValueForKey(l,e);const getAudioParamConnections=e=>getValueForKey(d,e);const deactivateActiveAudioNodeInputConnections=(e,t)=>{const{activeInputs:n}=getAudioNodeConnections(e);n.forEach((n=>n.forEach((([n])=>{t.includes(e)||deactivateActiveAudioNodeInputConnections(n,[...t,e])}))));const o=isAudioBufferSourceNode(e)?[e.playbackRate]:isAudioWorkletNode(e)?Array.from(e.parameters.values()):isBiquadFilterNode(e)?[e.Q,e.detune,e.frequency,e.gain]:isConstantSourceNode(e)?[e.offset]:isGainNode(e)?[e.gain]:isOscillatorNode(e)?[e.detune,e.frequency]:isStereoPannerNode(e)?[e.pan]:[];for(const e of o){const n=getAudioParamConnections(e);n!==void 0&&n.activeInputs.forEach((([e])=>deactivateActiveAudioNodeInputConnections(e,t)))}isActiveAudioNode(e)&&setInternalStateToPassive(e)};const deactivateAudioGraph=e=>{deactivateActiveAudioNodeInputConnections(e.destination,[])};const isValidLatencyHint=e=>e===void 0||typeof e==="number"||typeof e==="string"&&(e==="balanced"||e==="interactive"||e==="playback");const createAudioContextConstructor=(e,t,n,o,r,s,a,c,i)=>class AudioContext extends e{constructor(e={}){if(i===null)throw new Error("Missing the native AudioContext constructor.");let t;try{t=new i(e)}catch(e){if(e.code===12&&e.message==="sampleRate is not in range")throw n();throw e}if(t===null)throw o();if(!isValidLatencyHint(e.latencyHint))throw new TypeError(`The provided value '${e.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(e.sampleRate!==void 0&&t.sampleRate!==e.sampleRate)throw n();super(t,2);const{latencyHint:r}=e;const{sampleRate:s}=t;this._baseLatency=typeof t.baseLatency==="number"?t.baseLatency:r==="balanced"?512/s:r==="interactive"||r===void 0?256/s:r==="playback"?1024/s:Math.max(2,Math.min(128,Math.round(r*s/128)))*128/s;this._nativeAudioContext=t;if(i.name==="webkitAudioContext"){this._nativeGainNode=t.createGain();this._nativeOscillatorNode=t.createOscillator();this._nativeGainNode.gain.value=1e-37;this._nativeOscillatorNode.connect(this._nativeGainNode).connect(t.destination);this._nativeOscillatorNode.start()}else{this._nativeGainNode=null;this._nativeOscillatorNode=null}this._state=null;if(t.state==="running"){this._state="suspended";const revokeState=()=>{this._state==="suspended"&&(this._state=null);t.removeEventListener("statechange",revokeState)};t.addEventListener("statechange",revokeState)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){if(this.state==="closed")return this._nativeAudioContext.close().then((()=>{throw t()}));this._state==="suspended"&&(this._state=null);return this._nativeAudioContext.close().then((()=>{if(this._nativeGainNode!==null&&this._nativeOscillatorNode!==null){this._nativeOscillatorNode.stop();this._nativeGainNode.disconnect();this._nativeOscillatorNode.disconnect()}deactivateAudioGraph(this)}))}createMediaElementSource(e){return new r(this,{mediaElement:e})}createMediaStreamDestination(){return new s(this)}createMediaStreamSource(e){return new a(this,{mediaStream:e})}createMediaStreamTrackSource(e){return new c(this,{mediaStreamTrack:e})}resume(){return this._state==="suspended"?new Promise(((e,t)=>{const resolvePromise=()=>{this._nativeAudioContext.removeEventListener("statechange",resolvePromise);this._nativeAudioContext.state==="running"?e():this.resume().then(e,t)};this._nativeAudioContext.addEventListener("statechange",resolvePromise)})):this._nativeAudioContext.resume().catch((e=>{if(e===void 0||e.code===15)throw t();throw e}))}suspend(){return this._nativeAudioContext.suspend().catch((e=>{if(e===void 0)throw t();throw e}))}};const createAudioDestinationNodeConstructor=(e,t,n,o,r,s,a,c)=>class AudioDestinationNode extends e{constructor(e,n){const o=s(e);const i=a(o);const l=r(o,n,i);const u=i?t(c):null;super(e,false,l,u);this._isNodeOfNativeOfflineAudioContext=i;this._nativeAudioDestinationNode=l}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(e){if(this._isNodeOfNativeOfflineAudioContext)throw o();if(e>this._nativeAudioDestinationNode.maxChannelCount)throw n();this._nativeAudioDestinationNode.channelCount=e}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(e){if(this._isNodeOfNativeOfflineAudioContext)throw o();this._nativeAudioDestinationNode.channelCountMode=e}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}};const createAudioDestinationNodeRenderer=e=>{const t=new WeakMap;const createAudioDestinationNode=async(n,o)=>{const r=o.destination;t.set(o,r);await e(n,o,r);return r};return{render(e,n){const o=t.get(n);return o!==void 0?Promise.resolve(o):createAudioDestinationNode(e,n)}}};const createAudioListenerFactory=(e,t,n,o,r,s,a,c)=>(i,l)=>{const u=l.listener;const createFakeAudioParams=()=>{const d=new Float32Array(1);const h=t(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9});const f=a(l);let p=false;let m=[0,0,-1,0,1,0];let v=[0,0,0];const createScriptProcessorNode=()=>{if(p)return;p=true;const e=o(l,256,9,0);e.onaudioprocess=({inputBuffer:e})=>{const t=[s(e,d,0),s(e,d,1),s(e,d,2),s(e,d,3),s(e,d,4),s(e,d,5)];if(t.some(((e,t)=>e!==m[t]))){u.setOrientation(...t);m=t}const n=[s(e,d,6),s(e,d,7),s(e,d,8)];if(n.some(((e,t)=>e!==v[t]))){u.setPosition(...n);v=n}};h.connect(e)};const createSetOrientation=e=>t=>{if(t!==m[e]){m[e]=t;u.setOrientation(...m)}};const createSetPosition=e=>t=>{if(t!==v[e]){v[e]=t;u.setPosition(...v)}};const createFakeAudioParam=(t,o,s)=>{const a=n(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:o});a.connect(h,0,t);a.start();Object.defineProperty(a.offset,"defaultValue",{get(){return o}});const u=e({context:i},f,a.offset,b,M);c(u,"value",(e=>()=>e.call(u)),(e=>t=>{try{e.call(u,t)}catch(e){if(e.code!==9)throw e}createScriptProcessorNode();f&&s(t)}));u.cancelAndHoldAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.cancelAndHoldAtTime);u.cancelScheduledValues=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.cancelScheduledValues);u.exponentialRampToValueAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.exponentialRampToValueAtTime);u.linearRampToValueAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.linearRampToValueAtTime);u.setTargetAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.setTargetAtTime);u.setValueAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.setValueAtTime);u.setValueCurveAtTime=(e=>f?()=>{throw r()}:(...t)=>{const n=e.apply(u,t);createScriptProcessorNode();return n})(u.setValueCurveAtTime);return u};return{forwardX:createFakeAudioParam(0,0,createSetOrientation(0)),forwardY:createFakeAudioParam(1,0,createSetOrientation(1)),forwardZ:createFakeAudioParam(2,-1,createSetOrientation(2)),positionX:createFakeAudioParam(6,0,createSetPosition(0)),positionY:createFakeAudioParam(7,0,createSetPosition(1)),positionZ:createFakeAudioParam(8,0,createSetPosition(2)),upX:createFakeAudioParam(3,0,createSetOrientation(3)),upY:createFakeAudioParam(4,1,createSetOrientation(4)),upZ:createFakeAudioParam(5,0,createSetOrientation(5))}};const{forwardX:d,forwardY:h,forwardZ:f,positionX:p,positionY:m,positionZ:v,upX:g,upY:C,upZ:w}=u.forwardX===void 0?createFakeAudioParams():u;return{get forwardX(){return d},get forwardY(){return h},get forwardZ(){return f},get positionX(){return p},get positionY(){return m},get positionZ(){return v},get upX(){return g},get upY(){return C},get upZ(){return w}}};const isAudioNode=e=>"context"in e;const isAudioNodeOutputConnection=e=>isAudioNode(e[0]);const insertElementInSet=(e,t,n,o)=>{for(const t of e)if(n(t)){if(o)return false;throw Error("The set contains at least one similar element.")}e.add(t);return true};const addActiveInputConnectionToAudioParam=(e,t,[n,o],r)=>{insertElementInSet(e,[t,n,o],(e=>e[0]===t&&e[1]===n),r)};const addPassiveInputConnectionToAudioParam=(e,[t,n,o],r)=>{const s=e.get(t);s===void 0?e.set(t,new Set([[n,o]])):insertElementInSet(s,[n,o],(e=>e[0]===n),r)};const isNativeAudioNodeFaker=e=>"inputs"in e;const connectNativeAudioNodeToNativeAudioNode=(e,t,n,o)=>{if(isNativeAudioNodeFaker(t)){const r=t.inputs[o];e.connect(r,n,0);return[r,n,0]}e.connect(t,n,o);return[t,n,o]};const deleteActiveInputConnection=(e,t,n)=>{for(const o of e)if(o[0]===t&&o[1]===n){e.delete(o);return o}return null};const deleteActiveInputConnectionToAudioParam=(e,t,n)=>pickElementFromSet(e,(e=>e[0]===t&&e[1]===n));const deleteEventListenerOfAudioNode=(e,t)=>{const n=getEventListenersOfAudioNode(e);if(!n.delete(t))throw new Error("Missing the expected event listener.")};const deletePassiveInputConnectionToAudioParam=(e,t,n)=>{const o=getValueForKey(e,t);const r=pickElementFromSet(o,(e=>e[0]===n));o.size===0&&e.delete(t);return r};const disconnectNativeAudioNodeFromNativeAudioNode=(e,t,n,o)=>{isNativeAudioNodeFaker(t)?e.disconnect(t.inputs[o],n,0):e.disconnect(t,n,o)};const getNativeAudioNode=e=>getValueForKey(u,e);const getNativeAudioParam=e=>getValueForKey(h,e);const isPartOfACycle=e=>m.has(e);const isPassiveAudioNode=e=>!i.has(e);const testAudioNodeDisconnectMethodSupport=(e,t)=>new Promise((n=>{if(t!==null)n(true);else{const t=e.createScriptProcessor(256,1,1);const o=e.createGain();const r=e.createBuffer(1,2,44100);const s=r.getChannelData(0);s[0]=1;s[1]=1;const a=e.createBufferSource();a.buffer=r;a.loop=true;a.connect(t).connect(e.destination);a.connect(o);a.disconnect(o);t.onaudioprocess=o=>{const r=o.inputBuffer.getChannelData(0);Array.prototype.some.call(r,(e=>e===1))?n(true):n(false);a.stop();t.onaudioprocess=null;a.disconnect(t);t.disconnect(e.destination)};a.start()}}));const visitEachAudioNodeOnce=(e,t)=>{const n=new Map;for(const t of e)for(const e of t){const t=n.get(e);n.set(e,t===void 0?1:t+1)}n.forEach(((e,n)=>t(n,e)))};const isNativeAudioNode$1=e=>"context"in e;const wrapAudioNodeDisconnectMethod=e=>{const t=new Map;e.connect=(e=>(n,o=0,r=0)=>{const s=isNativeAudioNode$1(n)?e(n,o,r):e(n,o);const a=t.get(n);a===void 0?t.set(n,[{input:r,output:o}]):a.every((e=>e.input!==r||e.output!==o))&&a.push({input:r,output:o});return s})(e.connect.bind(e));e.disconnect=(n=>(o,r,s)=>{n.apply(e);if(o===void 0)t.clear();else if(typeof o==="number")for(const[e,n]of t){const r=n.filter((e=>e.output!==o));r.length===0?t.delete(e):t.set(e,r)}else if(t.has(o))if(r===void 0)t.delete(o);else{const e=t.get(o);if(e!==void 0){const n=e.filter((e=>e.output!==r&&(e.input!==s||s===void 0)));n.length===0?t.delete(o):t.set(o,n)}}for(const[n,o]of t)o.forEach((t=>{isNativeAudioNode$1(n)?e.connect(n,t.output,t.input):e.connect(n,t.output)}))})(e.disconnect)};const addConnectionToAudioParamOfAudioContext=(e,t,n,o)=>{const{activeInputs:r,passiveInputs:s}=getAudioParamConnections(t);const{outputs:a}=getAudioNodeConnections(e);const c=getEventListenersOfAudioNode(e);const eventListener=a=>{const c=getNativeAudioNode(e);const i=getNativeAudioParam(t);if(a){const t=deletePassiveInputConnectionToAudioParam(s,e,n);addActiveInputConnectionToAudioParam(r,e,t,false);o||isPartOfACycle(e)||c.connect(i,n)}else{const t=deleteActiveInputConnectionToAudioParam(r,e,n);addPassiveInputConnectionToAudioParam(s,t,false);o||isPartOfACycle(e)||c.disconnect(i,n)}};if(insertElementInSet(a,[t,n],(e=>e[0]===t&&e[1]===n),true)){c.add(eventListener);isActiveAudioNode(e)?addActiveInputConnectionToAudioParam(r,e,[n,eventListener],true):addPassiveInputConnectionToAudioParam(s,[e,n,eventListener],true);return true}return false};const deleteInputConnectionOfAudioNode=(e,t,n,o)=>{const{activeInputs:r,passiveInputs:s}=getAudioNodeConnections(t);const a=deleteActiveInputConnection(r[o],e,n);if(a===null){const t=deletePassiveInputConnectionToAudioNode(s,e,n,o);return[t[2],false]}return[a[2],true]};const deleteInputConnectionOfAudioParam=(e,t,n)=>{const{activeInputs:o,passiveInputs:r}=getAudioParamConnections(t);const s=deleteActiveInputConnection(o,e,n);if(s===null){const t=deletePassiveInputConnectionToAudioParam(r,e,n);return[t[1],false]}return[s[2],true]};const deleteInputsOfAudioNode=(e,t,n,o,r)=>{const[s,a]=deleteInputConnectionOfAudioNode(e,n,o,r);if(s!==null){deleteEventListenerOfAudioNode(e,s);!a||t||isPartOfACycle(e)||disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(e),getNativeAudioNode(n),o,r)}if(isActiveAudioNode(n)){const{activeInputs:e}=getAudioNodeConnections(n);setInternalStateToPassiveWhenNecessary(n,e)}};const deleteInputsOfAudioParam=(e,t,n,o)=>{const[r,s]=deleteInputConnectionOfAudioParam(e,n,o);if(r!==null){deleteEventListenerOfAudioNode(e,r);!s||t||isPartOfACycle(e)||getNativeAudioNode(e).disconnect(getNativeAudioParam(n),o)}};const deleteAnyConnection=(e,t)=>{const n=getAudioNodeConnections(e);const o=[];for(const r of n.outputs){isAudioNodeOutputConnection(r)?deleteInputsOfAudioNode(e,t,...r):deleteInputsOfAudioParam(e,t,...r);o.push(r[0])}n.outputs.clear();return o};const deleteConnectionAtOutput=(e,t,n)=>{const o=getAudioNodeConnections(e);const r=[];for(const s of o.outputs)if(s[1]===n){isAudioNodeOutputConnection(s)?deleteInputsOfAudioNode(e,t,...s):deleteInputsOfAudioParam(e,t,...s);r.push(s[0]);o.outputs.delete(s)}return r};const deleteConnectionToDestination=(e,t,n,o,r)=>{const s=getAudioNodeConnections(e);return Array.from(s.outputs).filter((e=>e[0]===n&&(o===void 0||e[1]===o)&&(r===void 0||e[2]===r))).map((n=>{isAudioNodeOutputConnection(n)?deleteInputsOfAudioNode(e,t,...n):deleteInputsOfAudioParam(e,t,...n);s.outputs.delete(n);return n[0]}))};const createAudioNodeConstructor=(e,t,n,o,r,s,a,c,i,l,d,h,f,m,v,g)=>class AudioNode extends l{constructor(t,o,r,s){super(r);this._context=t;this._nativeAudioNode=r;const a=d(t);h(a)&&true!==n(testAudioNodeDisconnectMethodSupport,(()=>testAudioNodeDisconnectMethodSupport(a,g)))&&wrapAudioNodeDisconnectMethod(r);u.set(this,r);p.set(this,new Set);t.state!=="closed"&&o&&setInternalStateToActive(this);e(this,s,r)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(e){this._nativeAudioNode.channelCount=e}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(e){this._nativeAudioNode.channelCountMode=e}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(e){this._nativeAudioNode.channelInterpretation=e}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(e,n=0,c=0){if(n<0||n>=this._nativeAudioNode.numberOfOutputs)throw r();const l=d(this._context);const u=v(l);if(f(e)||m(e))throw s();if(isAudioNode(e)){const r=getNativeAudioNode(e);try{const t=connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode,r,n,c);const o=isPassiveAudioNode(this);(u||o)&&this._nativeAudioNode.disconnect(...t);this.context.state!=="closed"&&!o&&isPassiveAudioNode(e)&&setInternalStateToActive(e)}catch(e){if(e.code===12)throw s();throw e}const a=t(this,e,n,c,u);if(a){const t=i([this],e);visitEachAudioNodeOnce(t,o(u))}return e}const h=getNativeAudioParam(e);if(h.name==="playbackRate"&&h.maxValue===1024)throw a();try{this._nativeAudioNode.connect(h,n);(u||isPassiveAudioNode(this))&&this._nativeAudioNode.disconnect(h,n)}catch(e){if(e.code===12)throw s();throw e}const p=addConnectionToAudioParamOfAudioContext(this,e,n,u);if(p){const t=i([this],e);visitEachAudioNodeOnce(t,o(u))}}disconnect(e,t,n){let o;const a=d(this._context);const l=v(a);if(e===void 0)o=deleteAnyConnection(this,l);else if(typeof e==="number"){if(e<0||e>=this.numberOfOutputs)throw r();o=deleteConnectionAtOutput(this,l,e)}else{if(t!==void 0&&(t<0||t>=this.numberOfOutputs))throw r();if(isAudioNode(e)&&n!==void 0&&(n<0||n>=e.numberOfInputs))throw r();o=deleteConnectionToDestination(this,l,e,t,n);if(o.length===0)throw s()}for(const e of o){const t=i([this],e);visitEachAudioNodeOnce(t,c)}}};const createAudioParamFactory=(t,n,o,r,s,a,c,i,l,u,d,h,f)=>(p,m,v,g=null,C=null)=>{const w=v.value;const y=new e(w);const _=m?r(y):null;const M={get defaultValue(){return w},get maxValue(){return g===null?v.maxValue:g},get minValue(){return C===null?v.minValue:C},get value(){return v.value},set value(e){v.value=e;M.setValueAtTime(e,p.context.currentTime)},cancelAndHoldAtTime(e){if(typeof v.cancelAndHoldAtTime==="function"){_===null&&y.flush(p.context.currentTime);y.add(s(e));v.cancelAndHoldAtTime(e)}else{const t=Array.from(y).pop();_===null&&y.flush(p.context.currentTime);y.add(s(e));const n=Array.from(y).pop();v.cancelScheduledValues(e);t!==n&&n!==void 0&&(n.type==="exponentialRampToValue"?v.exponentialRampToValueAtTime(n.value,n.endTime):n.type==="linearRampToValue"?v.linearRampToValueAtTime(n.value,n.endTime):n.type==="setValue"?v.setValueAtTime(n.value,n.startTime):n.type==="setValueCurve"&&v.setValueCurveAtTime(n.values,n.startTime,n.duration))}return M},cancelScheduledValues(e){_===null&&y.flush(p.context.currentTime);y.add(a(e));v.cancelScheduledValues(e);return M},exponentialRampToValueAtTime(e,t){if(e===0)throw new RangeError;if(!Number.isFinite(t)||t<0)throw new RangeError;const n=p.context.currentTime;_===null&&y.flush(n);if(Array.from(y).length===0){y.add(u(w,n));v.setValueAtTime(w,n)}y.add(c(e,t));v.exponentialRampToValueAtTime(e,t);return M},linearRampToValueAtTime(e,t){const n=p.context.currentTime;_===null&&y.flush(n);if(Array.from(y).length===0){y.add(u(w,n));v.setValueAtTime(w,n)}y.add(i(e,t));v.linearRampToValueAtTime(e,t);return M},setTargetAtTime(e,t,n){_===null&&y.flush(p.context.currentTime);y.add(l(e,t,n));v.setTargetAtTime(e,t,n);return M},setValueAtTime(e,t){_===null&&y.flush(p.context.currentTime);y.add(u(e,t));v.setValueAtTime(e,t);return M},setValueCurveAtTime(e,t,n){const o=e instanceof Float32Array?e:new Float32Array(e);if(h!==null&&h.name==="webkitAudioContext"){const e=t+n;const r=p.context.sampleRate;const s=Math.ceil(t*r);const a=Math.floor(e*r);const c=a-s;const i=new Float32Array(c);for(let e=0;e<c;e+=1){const a=(o.length-1)/n*((s+e)/r-t);const c=Math.floor(a);const l=Math.ceil(a);i[e]=c===l?o[c]:(1-(a-c))*o[c]+(1-(l-a))*o[l]}_===null&&y.flush(p.context.currentTime);y.add(d(i,t,n));v.setValueCurveAtTime(i,t,n);const l=a/r;l<e&&f(M,i[i.length-1],l);f(M,o[o.length-1],e)}else{_===null&&y.flush(p.context.currentTime);y.add(d(o,t,n));v.setValueCurveAtTime(o,t,n)}return M}};o.set(M,v);n.set(M,p);t(M,_);return M};const createAudioParamRenderer=e=>({replay(t){for(const n of e)if(n.type==="exponentialRampToValue"){const{endTime:e,value:o}=n;t.exponentialRampToValueAtTime(o,e)}else if(n.type==="linearRampToValue"){const{endTime:e,value:o}=n;t.linearRampToValueAtTime(o,e)}else if(n.type==="setTarget"){const{startTime:e,target:o,timeConstant:r}=n;t.setTargetAtTime(o,e,r)}else if(n.type==="setValue"){const{startTime:e,value:o}=n;t.setValueAtTime(o,e)}else{if(n.type!=="setValueCurve")throw new Error("Can't apply an unknown automation.");{const{duration:e,startTime:o,values:r}=n;t.setValueCurveAtTime(r,o,e)}}}});class ReadOnlyMap{constructor(e){this._map=new Map(e)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(e,t=null){return this._map.forEach(((n,o)=>e.call(t,n,o,this)))}get(e){return this._map.get(e)}has(e){return this._map.has(e)}keys(){return this._map.keys()}values(){return this._map.values()}}const O={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}};const createAudioWorkletNodeConstructor=(e,t,n,o,r,s,a,c,i,l,u,d,h,f)=>class AudioWorkletNode extends t{constructor(t,f,p){var m;const g=c(t);const C=i(g);const w=u({...O,...p});h(w);const y=v.get(g);const _=y===null||y===void 0?void 0:y.get(f);const M=C||g.state!=="closed"?g:(m=a(g))!==null&&m!==void 0?m:g;const b=r(M,C?null:t.baseLatency,l,f,_,w);const A=C?o(f,w,_):null;super(t,true,b,A);const x=[];b.parameters.forEach(((e,t)=>{const o=n(this,C,e);x.push([t,o])}));this._nativeAudioWorkletNode=b;this._onprocessorerror=null;this._parameters=new ReadOnlyMap(x);C&&e(g,this);const{activeInputs:N}=s(this);d(b,N)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(e){const t=typeof e==="function"?f(this,e):null;this._nativeAudioWorkletNode.onprocessorerror=t;const n=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=n!==null&&n===t?e:n}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function copyFromChannel(e,t,n,o,r){if(typeof e.copyFromChannel==="function"){t[n].byteLength===0&&(t[n]=new Float32Array(128));e.copyFromChannel(t[n],o,r)}else{const s=e.getChannelData(o);if(t[n].byteLength===0)t[n]=s.slice(r,r+128);else{const e=new Float32Array(s.buffer,r*Float32Array.BYTES_PER_ELEMENT,128);t[n].set(e)}}}const copyToChannel=(e,t,n,o,r)=>{typeof e.copyToChannel==="function"?t[n].byteLength!==0&&e.copyToChannel(t[n],o,r):t[n].byteLength!==0&&e.getChannelData(o).set(t[n],r)};const createNestedArrays=(e,t)=>{const n=[];for(let o=0;o<e;o+=1){const e=[];const r=typeof t==="number"?t:t[o];for(let t=0;t<r;t+=1)e.push(new Float32Array(128));n.push(e)}return n};const getAudioWorkletProcessor=(e,t)=>{const n=getValueForKey(g,e);const o=getNativeAudioNode(t);return getValueForKey(n,o)};const processBuffer=async(e,t,n,o,r,s,a)=>{const c=t===null?Math.ceil(e.context.length/128)*128:t.length;const i=o.channelCount*o.numberOfInputs;const l=r.reduce(((e,t)=>e+t),0);const u=l===0?null:n.createBuffer(l,c,n.sampleRate);if(s===void 0)throw new Error("Missing the processor constructor.");const d=getAudioNodeConnections(e);const h=await getAudioWorkletProcessor(n,e);const f=createNestedArrays(o.numberOfInputs,o.channelCount);const p=createNestedArrays(o.numberOfOutputs,r);const m=Array.from(e.parameters.keys()).reduce(((e,t)=>({...e,[t]:new Float32Array(128)})),{});for(let l=0;l<c;l+=128){if(o.numberOfInputs>0&&t!==null)for(let e=0;e<o.numberOfInputs;e+=1)for(let n=0;n<o.channelCount;n+=1)copyFromChannel(t,f[e],n,n,l);s.parameterDescriptors!==void 0&&t!==null&&s.parameterDescriptors.forEach((({name:e},n)=>{copyFromChannel(t,m,e,i+n,l)}));for(let e=0;e<o.numberOfInputs;e+=1)for(let t=0;t<r[e];t+=1)p[e][t].byteLength===0&&(p[e][t]=new Float32Array(128));try{const e=f.map(((e,t)=>d.activeInputs[t].size===0?[]:e));const t=a(l/n.sampleRate,n.sampleRate,(()=>h.process(e,p,m)));if(u!==null)for(let e=0,t=0;e<o.numberOfOutputs;e+=1){for(let n=0;n<r[e];n+=1)copyToChannel(u,p[e],n,t+n,l);t+=r[e]}if(!t)break}catch(t){e.dispatchEvent(new ErrorEvent("processorerror",{colno:t.colno,filename:t.filename,lineno:t.lineno,message:t.message}));break}}return u};const createAudioWorkletNodeRendererFactory=(e,t,n,o,r,s,a,c,i,l,u,d,h,f,p,m)=>(v,g,C)=>{const w=new WeakMap;let y=null;const createAudioNode=async(c,_)=>{let M=u(c);let b=null;const A=isOwnedByContext(M,_);const O=Array.isArray(g.outputChannelCount)?g.outputChannelCount:Array.from(g.outputChannelCount);if(d===null){const e=O.reduce(((e,t)=>e+t),0);const n=r(_,{channelCount:Math.max(1,e),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,e)});const s=[];for(let e=0;e<c.numberOfOutputs;e+=1)s.push(o(_,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:O[e]}));const l=a(_,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1});l.connect=t.bind(null,s);l.disconnect=i.bind(null,s);b=[n,s,l]}else A||(M=new d(_,v));w.set(_,b===null?M:b[2]);if(b!==null){if(y===null){if(C===void 0)throw new Error("Missing the processor constructor.");if(h===null)throw new Error("Missing the native OfflineAudioContext constructor.");const e=c.channelCount*c.numberOfInputs;const t=C.parameterDescriptors===void 0?0:C.parameterDescriptors.length;const n=e+t;const renderBuffer=async()=>{const i=new h(n,Math.ceil(c.context.length/128)*128,_.sampleRate);const l=[];const u=[];for(let e=0;e<g.numberOfInputs;e+=1){l.push(a(i,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1}));u.push(r(i,{channelCount:g.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:g.channelCount}))}const d=await Promise.all(Array.from(c.parameters.values()).map((async e=>{const t=s(i,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:e.value});await f(i,e,t.offset);return t})));const v=o(i,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,e+t)});for(let e=0;e<g.numberOfInputs;e+=1){l[e].connect(u[e]);for(let t=0;t<g.channelCount;t+=1)u[e].connect(v,t,e*g.channelCount+t)}for(const[t,n]of d.entries()){n.connect(v,0,e+t);n.start(0)}v.connect(i.destination);await Promise.all(l.map((e=>p(c,i,e))));return m(i)};y=processBuffer(c,n===0?null:await renderBuffer(),_,g,O,C,l)}const e=await y;const t=n(_,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:false,loopEnd:0,loopStart:0,playbackRate:1});const[i,u,d]=b;if(e!==null){t.buffer=e;t.start(0)}t.connect(i);for(let e=0,t=0;e<c.numberOfOutputs;e+=1){const n=u[e];for(let o=0;o<O[e];o+=1)i.connect(n,t+o,o);t+=O[e]}return d}if(A)for(const[t,n]of c.parameters.entries())await e(_,n,M.parameters.get(t));else for(const[e,t]of c.parameters.entries())await f(_,t,M.parameters.get(e));await p(c,_,M);return M};return{render(e,t){c(t,e);const n=w.get(t);return n!==void 0?Promise.resolve(n):createAudioNode(e,t)}}};const createBaseAudioContextConstructor=(e,t,n,o,r,s,a,c,i,l,u,d,h,f,p,m,v,g,C,w)=>class BaseAudioContext extends p{constructor(t,n){super(t,n);this._nativeContext=t;this._audioWorklet=e===void 0?void 0:{addModule:(t,n)=>e(this,t,n)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new t(this)}createBiquadFilter(){return new r(this)}createBuffer(e,t,o){return new n({length:t,numberOfChannels:e,sampleRate:o})}createBufferSource(){return new o(this)}createChannelMerger(e=6){return new s(this,{numberOfInputs:e})}createChannelSplitter(e=6){return new a(this,{numberOfOutputs:e})}createConstantSource(){return new c(this)}createConvolver(){return new i(this)}createDelay(e=1){return new u(this,{maxDelayTime:e})}createDynamicsCompressor(){return new d(this)}createGain(){return new h(this)}createIIRFilter(e,t){return new f(this,{feedback:t,feedforward:e})}createOscillator(){return new m(this)}createPanner(){return new v(this)}createPeriodicWave(e,t,n={disableNormalization:false}){return new g(this,{...n,imag:t,real:e})}createStereoPanner(){return new C(this)}createWaveShaper(){return new w(this)}decodeAudioData(e,t,n){return l(this._nativeContext,e).then((e=>{typeof t==="function"&&t(e);return e}),(e=>{typeof n==="function"&&n(e);throw e}))}};const x={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"};const createBiquadFilterNodeConstructor=(e,t,n,o,r,s,a,c)=>class BiquadFilterNode extends e{constructor(e,o){const i=s(e);const l={...x,...o};const u=r(i,l);const d=a(i);const h=d?n():null;super(e,false,u,h);this._Q=t(this,d,u.Q,b,M);this._detune=t(this,d,u.detune,1200*Math.log2(b),-1200*Math.log2(b));this._frequency=t(this,d,u.frequency,e.sampleRate/2,0);this._gain=t(this,d,u.gain,40*Math.log10(b),M);this._nativeBiquadFilterNode=u;c(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(e){this._nativeBiquadFilterNode.type=e}getFrequencyResponse(e,t,n){try{this._nativeBiquadFilterNode.getFrequencyResponse(e,t,n)}catch(e){if(e.code===11)throw o();throw e}if(e.length!==t.length||t.length!==n.length)throw o()}};const createBiquadFilterNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;const createBiquadFilterNode=async(a,c)=>{let i=n(a);const l=isOwnedByContext(i,c);if(!l){const e={Q:i.Q.value,channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation,detune:i.detune.value,frequency:i.frequency.value,gain:i.gain.value,type:i.type};i=t(c,e)}s.set(c,i);if(l){await e(c,a.Q,i.Q);await e(c,a.detune,i.detune);await e(c,a.frequency,i.frequency);await e(c,a.gain,i.gain)}else{await o(c,a.Q,i.Q);await o(c,a.detune,i.detune);await o(c,a.frequency,i.frequency);await o(c,a.gain,i.gain)}await r(a,c,i);return i};return{render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createBiquadFilterNode(e,t)}}};const createCacheTestResult=(e,t)=>(n,o)=>{const r=t.get(n);if(r!==void 0)return r;const s=e.get(n);if(s!==void 0)return s;try{const r=o();if(r instanceof Promise){e.set(n,r);return r.catch((()=>false)).then((o=>{e.delete(n);t.set(n,o);return o}))}t.set(n,r);return r}catch{t.set(n,false);return false}};const N={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6};const createChannelMergerNodeConstructor=(e,t,n,o,r)=>class ChannelMergerNode extends e{constructor(e,s){const a=o(e);const c={...N,...s};const i=n(a,c);const l=r(a)?t():null;super(e,false,i,l)}};const createChannelMergerNodeRendererFactory=(e,t,n)=>()=>{const o=new WeakMap;const createAudioNode=async(r,s)=>{let a=t(r);const c=isOwnedByContext(a,s);if(!c){const t={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,numberOfInputs:a.numberOfInputs};a=e(s,t)}o.set(s,a);await n(r,s,a);return a};return{render(e,t){const n=o.get(t);return n!==void 0?Promise.resolve(n):createAudioNode(e,t)}}};const I={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6};const createChannelSplitterNodeConstructor=(e,t,n,o,r,s)=>class ChannelSplitterNode extends e{constructor(e,a){const c=o(e);const i=s({...I,...a});const l=n(c,i);const u=r(c)?t():null;super(e,false,l,u)}};const createChannelSplitterNodeRendererFactory=(e,t,n)=>()=>{const o=new WeakMap;const createAudioNode=async(r,s)=>{let a=t(r);const c=isOwnedByContext(a,s);if(!c){const t={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,numberOfOutputs:a.numberOfOutputs};a=e(s,t)}o.set(s,a);await n(r,s,a);return a};return{render(e,t){const n=o.get(t);return n!==void 0?Promise.resolve(n):createAudioNode(e,t)}}};const createConnectAudioParam=e=>(t,n,o)=>e(n,t,o);const createConnectMultipleOutputs=e=>(t,n,o=0,r=0)=>{const s=t[o];if(s===void 0)throw e();return isNativeAudioNode$1(n)?s.connect(n,0,r):s.connect(n,0)};const createConnectedNativeAudioBufferSourceNodeFactory=e=>(t,n)=>{const o=e(t,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:false,loopEnd:0,loopStart:0,playbackRate:1});const r=t.createBuffer(1,2,44100);o.buffer=r;o.loop=true;o.connect(n);o.start();return()=>{o.stop();o.disconnect(n)}};const E={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1};const createConstantSourceNodeConstructor=(e,t,n,o,r,s,a)=>class ConstantSourceNode extends e{constructor(e,a){const c=r(e);const i={...E,...a};const l=o(c,i);const u=s(c);const d=u?n():null;super(e,false,l,d);this._constantSourceNodeRenderer=d;this._nativeConstantSourceNode=l;this._offset=t(this,u,l.offset,b,M);this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(e){const t=typeof e==="function"?a(this,e):null;this._nativeConstantSourceNode.onended=t;const n=this._nativeConstantSourceNode.onended;this._onended=n!==null&&n===t?e:n}start(e=0){this._nativeConstantSourceNode.start(e);this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.start=e);if(this.context.state!=="closed"){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeConstantSourceNode.removeEventListener("ended",resetInternalStateToPassive);isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeConstantSourceNode.addEventListener("ended",resetInternalStateToPassive)}}stop(e=0){this._nativeConstantSourceNode.stop(e);this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.stop=e)}};const createConstantSourceNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;let a=null;let c=null;const createConstantSourceNode=async(i,l)=>{let u=n(i);const d=isOwnedByContext(u,l);if(!d){const e={channelCount:u.channelCount,channelCountMode:u.channelCountMode,channelInterpretation:u.channelInterpretation,offset:u.offset.value};u=t(l,e);a!==null&&u.start(a);c!==null&&u.stop(c)}s.set(l,u);d?await e(l,i.offset,u.offset):await o(l,i.offset,u.offset);await r(i,l,u);return u};return{set start(e){a=e},set stop(e){c=e},render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createConstantSourceNode(e,t)}}};const createConvertNumberToUnsignedLong=e=>t=>{e[0]=t;return e[0]};const S={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:false};const createConvolverNodeConstructor=(e,t,n,o,r,s)=>class ConvolverNode extends e{constructor(e,a){const c=o(e);const i={...S,...a};const l=n(c,i);const u=r(c);const d=u?t():null;super(e,false,l,d);this._isBufferNullified=false;this._nativeConvolverNode=l;i.buffer!==null&&s(this,i.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(e){this._nativeConvolverNode.buffer=e;if(e===null&&this._nativeConvolverNode.buffer!==null){const e=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=e.createBuffer(1,1,e.sampleRate);this._isBufferNullified=true;s(this,0)}else{this._isBufferNullified=false;s(this,this._nativeConvolverNode.buffer===null?0:this._nativeConvolverNode.buffer.duration)}}get normalize(){return this._nativeConvolverNode.normalize}set normalize(e){this._nativeConvolverNode.normalize=e}};const createConvolverNodeRendererFactory=(e,t,n)=>()=>{const o=new WeakMap;const createConvolverNode=async(r,s)=>{let a=t(r);const c=isOwnedByContext(a,s);if(!c){const t={buffer:a.buffer,channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,disableNormalization:!a.normalize};a=e(s,t)}o.set(s,a);isNativeAudioNodeFaker(a)?await n(r,s,a.inputs[0]):await n(r,s,a);return a};return{render(e,t){const n=o.get(t);return n!==void 0?Promise.resolve(n):createConvolverNode(e,t)}}};const createCreateNativeOfflineAudioContext=(e,t)=>(n,o,r)=>{if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new t(n,o,r)}catch(t){if(t.name==="SyntaxError")throw e();throw t}};const createDataCloneError=()=>new DOMException("","DataCloneError");const detachArrayBuffer=e=>{const{port1:t,port2:n}=new MessageChannel;return new Promise((o=>{const closeAndResolve=()=>{n.onmessage=null;t.close();n.close();o()};n.onmessage=()=>closeAndResolve();try{t.postMessage(e,[e])}catch{}finally{closeAndResolve()}}))};const createDecodeAudioData=(e,t,n,o,r,s,a,c,i,l,u)=>(d,h)=>{const f=a(d)?d:s(d);if(r.has(h)){const e=n();return Promise.reject(e)}try{r.add(h)}catch{}return t(i,(()=>i(f)))?f.decodeAudioData(h).then((n=>{detachArrayBuffer(h).catch((()=>{}));t(c,(()=>c(n)))||u(n);e.add(n);return n})):new Promise(((t,n)=>{const complete=async()=>{try{await detachArrayBuffer(h)}catch{}};const fail=e=>{n(e);complete()};try{f.decodeAudioData(h,(n=>{if(typeof n.copyFromChannel!=="function"){l(n);wrapAudioBufferGetChannelDataMethod(n)}e.add(n);complete().then((()=>t(n)))}),(e=>{fail(e===null?o():e)}))}catch(e){fail(e)}}))};const createDecrementCycleCounter=(e,t,n,o,r,s,a,c)=>(i,l)=>{const u=t.get(i);if(u===void 0)throw new Error("Missing the expected cycle count.");const d=s(i.context);const h=c(d);if(u===l){t.delete(i);if(!h&&a(i)){const t=o(i);const{outputs:s}=n(i);for(const n of s)if(isAudioNodeOutputConnection(n)){const r=o(n[0]);e(t,r,n[1],n[2])}else{const e=r(n[0]);t.connect(e,n[1])}}}else t.set(i,u-l)};const T={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1};const createDelayNodeConstructor=(e,t,n,o,r,s,a)=>class DelayNode extends e{constructor(e,c){const i=r(e);const l={...T,...c};const u=o(i,l);const d=s(i);const h=d?n(l.maxDelayTime):null;super(e,false,u,h);this._delayTime=t(this,d,u.delayTime);a(this,l.maxDelayTime)}get delayTime(){return this._delayTime}};const createDelayNodeRendererFactory=(e,t,n,o,r)=>s=>{const a=new WeakMap;const createDelayNode=async(c,i)=>{let l=n(c);const u=isOwnedByContext(l,i);if(!u){const e={channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,delayTime:l.delayTime.value,maxDelayTime:s};l=t(i,e)}a.set(i,l);u?await e(i,c.delayTime,l.delayTime):await o(i,c.delayTime,l.delayTime);await r(c,i,l);return l};return{render(e,t){const n=a.get(t);return n!==void 0?Promise.resolve(n):createDelayNode(e,t)}}};const createDeleteActiveInputConnectionToAudioNode=e=>(t,n,o,r)=>e(t[r],(e=>e[0]===n&&e[1]===o));const createDeleteUnrenderedAudioWorkletNode=e=>(t,n)=>{e(t).delete(n)};const isDelayNode=e=>"delayTime"in e;const createDetectCycles=(e,t,n)=>function detectCycles(o,r){const s=isAudioNode(r)?r:n(e,r);if(isDelayNode(s))return[];if(o[0]===s)return[o];if(o.includes(s))return[];const{outputs:a}=t(s);return Array.from(a).map((e=>detectCycles([...o,s],e[0]))).reduce(((e,t)=>e.concat(t)),[])};const getOutputAudioNodeAtIndex=(e,t,n)=>{const o=t[n];if(o===void 0)throw e();return o};const createDisconnectMultipleOutputs=e=>(t,n=void 0,o=void 0,r=0)=>n===void 0?t.forEach((e=>e.disconnect())):typeof n==="number"?getOutputAudioNodeAtIndex(e,t,n).disconnect():isNativeAudioNode$1(n)?o===void 0?t.forEach((e=>e.disconnect(n))):r===void 0?getOutputAudioNodeAtIndex(e,t,o).disconnect(n,0):getOutputAudioNodeAtIndex(e,t,o).disconnect(n,0,r):o===void 0?t.forEach((e=>e.disconnect(n))):getOutputAudioNodeAtIndex(e,t,o).disconnect(n,0);const k={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24};const createDynamicsCompressorNodeConstructor=(e,t,n,o,r,s,a,c)=>class DynamicsCompressorNode extends e{constructor(e,r){const i=s(e);const l={...k,...r};const u=o(i,l);const d=a(i);const h=d?n():null;super(e,false,u,h);this._attack=t(this,d,u.attack);this._knee=t(this,d,u.knee);this._nativeDynamicsCompressorNode=u;this._ratio=t(this,d,u.ratio);this._release=t(this,d,u.release);this._threshold=t(this,d,u.threshold);c(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(e){const t=this._nativeDynamicsCompressorNode.channelCount;this._nativeDynamicsCompressorNode.channelCount=e;if(e>2){this._nativeDynamicsCompressorNode.channelCount=t;throw r()}}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(e){const t=this._nativeDynamicsCompressorNode.channelCountMode;this._nativeDynamicsCompressorNode.channelCountMode=e;if(e==="max"){this._nativeDynamicsCompressorNode.channelCountMode=t;throw r()}}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return typeof this._nativeDynamicsCompressorNode.reduction.value==="number"?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}};const createDynamicsCompressorNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;const createDynamicsCompressorNode=async(a,c)=>{let i=n(a);const l=isOwnedByContext(i,c);if(!l){const e={attack:i.attack.value,channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation,knee:i.knee.value,ratio:i.ratio.value,release:i.release.value,threshold:i.threshold.value};i=t(c,e)}s.set(c,i);if(l){await e(c,a.attack,i.attack);await e(c,a.knee,i.knee);await e(c,a.ratio,i.ratio);await e(c,a.release,i.release);await e(c,a.threshold,i.threshold)}else{await o(c,a.attack,i.attack);await o(c,a.knee,i.knee);await o(c,a.ratio,i.ratio);await o(c,a.release,i.release);await o(c,a.threshold,i.threshold)}await r(a,c,i);return i};return{render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createDynamicsCompressorNode(e,t)}}};const createEncodingError=()=>new DOMException("","EncodingError");const createEvaluateSource=e=>t=>new Promise(((n,o)=>{if(e===null){o(new SyntaxError);return}const r=e.document.head;if(r===null)o(new SyntaxError);else{const s=e.document.createElement("script");const a=new Blob([t],{type:"application/javascript"});const c=URL.createObjectURL(a);const i=e.onerror;const removeErrorEventListenerAndRevokeUrl=()=>{e.onerror=i;URL.revokeObjectURL(c)};e.onerror=(t,n,r,s,a)=>{if(n===c||n===e.location.href&&r===1&&s===1){removeErrorEventListenerAndRevokeUrl();o(a);return false}if(i!==null)return i(t,n,r,s,a)};s.onerror=()=>{removeErrorEventListenerAndRevokeUrl();o(new SyntaxError)};s.onload=()=>{removeErrorEventListenerAndRevokeUrl();n()};s.src=c;s.type="module";r.appendChild(s)}}));const createEventTargetConstructor=e=>class EventTarget{constructor(e){this._nativeEventTarget=e;this._listeners=new WeakMap}addEventListener(t,n,o){if(n!==null){let r=this._listeners.get(n);if(r===void 0){r=e(this,n);typeof n==="function"&&this._listeners.set(n,r)}this._nativeEventTarget.addEventListener(t,r,o)}}dispatchEvent(e){return this._nativeEventTarget.dispatchEvent(e)}removeEventListener(e,t,n){const o=t===null?void 0:this._listeners.get(t);this._nativeEventTarget.removeEventListener(e,o===void 0?null:o,n)}};const createExposeCurrentFrameAndCurrentTime=e=>(t,n,o)=>{Object.defineProperties(e,{currentFrame:{configurable:true,get(){return Math.round(t*n)}},currentTime:{configurable:true,get(){return t}}});try{return o()}finally{if(e!==null){delete e.currentFrame;delete e.currentTime}}};const createFetchSource=e=>async t=>{try{const e=await fetch(t);if(e.ok)return[await e.text(),e.url]}catch{}throw e()};const D={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1};const createGainNodeConstructor=(e,t,n,o,r,s)=>class GainNode extends e{constructor(e,a){const c=r(e);const i={...D,...a};const l=o(c,i);const u=s(c);const d=u?n():null;super(e,false,l,d);this._gain=t(this,u,l.gain,b,M)}get gain(){return this._gain}};const createGainNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;const createGainNode=async(a,c)=>{let i=n(a);const l=isOwnedByContext(i,c);if(!l){const e={channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation,gain:i.gain.value};i=t(c,e)}s.set(c,i);l?await e(c,a.gain,i.gain):await o(c,a.gain,i.gain);await r(a,c,i);return i};return{render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createGainNode(e,t)}}};const createGetActiveAudioWorkletNodeInputs=(e,t)=>n=>t(e,n);const createGetAudioNodeRenderer=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return n.renderer};const createGetAudioNodeTailTime=e=>t=>{var n;return(n=e.get(t))!==null&&n!==void 0?n:0};const createGetAudioParamRenderer=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return n.renderer};const createGetBackupOfflineAudioContext=e=>t=>e.get(t);const createInvalidStateError=()=>new DOMException("","InvalidStateError");const createGetNativeContext=e=>t=>{const n=e.get(t);if(n===void 0)throw createInvalidStateError();return n};const createGetOrCreateBackupOfflineAudioContext=(e,t)=>n=>{let o=e.get(n);if(o!==void 0)return o;if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");o=new t(1,1,44100);e.set(n,o);return o};const createGetUnrenderedAudioWorkletNodes=e=>t=>{const n=e.get(t);if(n===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return n};const createInvalidAccessError=()=>new DOMException("","InvalidAccessError");const wrapIIRFilterNodeGetFrequencyResponseMethod=e=>{e.getFrequencyResponse=(t=>(n,o,r)=>{if(n.length!==o.length||o.length!==r.length)throw createInvalidAccessError();return t.call(e,n,o,r)})(e.getFrequencyResponse)};const P={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"};const createIIRFilterNodeConstructor=(e,t,n,o,r,s)=>class IIRFilterNode extends e{constructor(e,a){const c=o(e);const i=r(c);const l={...P,...a};const u=t(c,i?null:e.baseLatency,l);const d=i?n(l.feedback,l.feedforward):null;super(e,false,u,d);wrapIIRFilterNodeGetFrequencyResponseMethod(u);this._nativeIIRFilterNode=u;s(this,1)}getFrequencyResponse(e,t,n){return this._nativeIIRFilterNode.getFrequencyResponse(e,t,n)}};const filterBuffer=(e,t,n,o,r,s,a,c,i,l,u)=>{const d=l.length;let h=c;for(let c=0;c<d;c+=1){let d=n[0]*l[c];for(let t=1;t<r;t+=1){const o=h-t&i-1;d+=n[t]*s[o];d-=e[t]*a[o]}for(let e=r;e<o;e+=1)d+=n[e]*s[h-e&i-1];for(let n=r;n<t;n+=1)d-=e[n]*a[h-n&i-1];s[h]=l[c];a[h]=d;h=h+1&i-1;u[c]=d}return h};const filterFullBuffer=(e,t,n,o)=>{const r=n instanceof Float64Array?n:new Float64Array(n);const s=o instanceof Float64Array?o:new Float64Array(o);const a=r.length;const c=s.length;const i=Math.min(a,c);if(r[0]!==1){for(let e=0;e<a;e+=1)s[e]/=r[0];for(let e=1;e<c;e+=1)r[e]/=r[0]}const l=32;const u=new Float32Array(l);const d=new Float32Array(l);const h=t.createBuffer(e.numberOfChannels,e.length,e.sampleRate);const f=e.numberOfChannels;for(let t=0;t<f;t+=1){const n=e.getChannelData(t);const o=h.getChannelData(t);u.fill(0);d.fill(0);filterBuffer(r,a,s,c,i,u,d,0,l,n,o)}return h};const createIIRFilterNodeRendererFactory=(e,t,n,o,r)=>(s,a)=>{const c=new WeakMap;let i=null;const createAudioNode=async(l,u)=>{let d=null;let h=t(l);const f=isOwnedByContext(h,u);u.createIIRFilter===void 0?d=e(u,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:false,loopEnd:0,loopStart:0,playbackRate:1}):f||(h=u.createIIRFilter(a,s));c.set(u,d===null?h:d);if(d!==null){if(i===null){if(n===null)throw new Error("Missing the native OfflineAudioContext constructor.");const e=new n(l.context.destination.channelCount,l.context.length,u.sampleRate);i=(async()=>{await o(l,e,e.destination);const t=await r(e);return filterFullBuffer(t,u,s,a)})()}const e=await i;d.buffer=e;d.start(0);return d}await o(l,u,h);return h};return{render(e,t){const n=c.get(t);return n!==void 0?Promise.resolve(n):createAudioNode(e,t)}}};const createIncrementCycleCounterFactory=(e,t,n,o,r,s)=>a=>(c,i)=>{const l=e.get(c);if(l===void 0){if(!a&&s(c)){const e=o(c);const{outputs:s}=n(c);for(const n of s)if(isAudioNodeOutputConnection(n)){const r=o(n[0]);t(e,r,n[1],n[2])}else{const t=r(n[0]);e.disconnect(t,n[1])}}e.set(c,i)}else e.set(c,l+i)};const createIsAnyAudioContext=(e,t)=>n=>{const o=e.get(n);return t(o)||t(n)};const createIsAnyAudioNode=(e,t)=>n=>e.has(n)||t(n);const createIsAnyAudioParam=(e,t)=>n=>e.has(n)||t(n);const createIsAnyOfflineAudioContext=(e,t)=>n=>{const o=e.get(n);return t(o)||t(n)};const createIsNativeAudioContext=e=>t=>e!==null&&t instanceof e;const createIsNativeAudioNode=e=>t=>e!==null&&typeof e.AudioNode==="function"&&t instanceof e.AudioNode;const createIsNativeAudioParam=e=>t=>e!==null&&typeof e.AudioParam==="function"&&t instanceof e.AudioParam;const createIsNativeContext=(e,t)=>n=>e(n)||t(n);const createIsNativeOfflineAudioContext=e=>t=>e!==null&&t instanceof e;const createIsSecureContext=e=>e!==null&&e.isSecureContext;const createIsSupportedPromise=async(e,t,n,o,r,s,a,c,i,l,u,d,h,f,p,m)=>{if(e(t,t)&&e(n,n)&&e(r,r)&&e(s,s)&&e(c,c)&&e(i,i)&&e(l,l)&&e(u,u)&&e(d,d)&&e(h,h)&&e(f,f)){const t=await Promise.all([e(o,o),e(a,a),e(p,p),e(m,m)]);return t.every((e=>e))}return false};const createMediaElementAudioSourceNodeConstructor=(e,t,n,o)=>class MediaElementAudioSourceNode extends e{constructor(e,r){const s=n(e);const a=t(s,r);if(o(s))throw TypeError();super(e,true,a,null);this._nativeMediaElementAudioSourceNode=a}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}};const R={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"};const createMediaStreamAudioDestinationNodeConstructor=(e,t,n,o)=>class MediaStreamAudioDestinationNode extends e{constructor(e,r){const s=n(e);if(o(s))throw new TypeError;const a={...R,...r};const c=t(s,a);super(e,false,c,null);this._nativeMediaStreamAudioDestinationNode=c}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}};const createMediaStreamAudioSourceNodeConstructor=(e,t,n,o)=>class MediaStreamAudioSourceNode extends e{constructor(e,r){const s=n(e);const a=t(s,r);if(o(s))throw new TypeError;super(e,true,a,null);this._nativeMediaStreamAudioSourceNode=a}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}};const createMediaStreamTrackAudioSourceNodeConstructor=(e,t,n)=>class MediaStreamTrackAudioSourceNode extends e{constructor(e,o){const r=n(e);const s=t(r,o);super(e,true,s,null)}};const createMinimalAudioContextConstructor=(e,t,n,o,r)=>class MinimalAudioContext extends o{constructor(e={}){if(r===null)throw new Error("Missing the native AudioContext constructor.");let o;try{o=new r(e)}catch(e){if(e.code===12&&e.message==="sampleRate is not in range")throw t();throw e}if(o===null)throw n();if(!isValidLatencyHint(e.latencyHint))throw new TypeError(`The provided value '${e.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(e.sampleRate!==void 0&&o.sampleRate!==e.sampleRate)throw t();super(o,2);const{latencyHint:s}=e;const{sampleRate:a}=o;this._baseLatency=typeof o.baseLatency==="number"?o.baseLatency:s==="balanced"?512/a:s==="interactive"||s===void 0?256/a:s==="playback"?1024/a:Math.max(2,Math.min(128,Math.round(s*a/128)))*128/a;this._nativeAudioContext=o;if(r.name==="webkitAudioContext"){this._nativeGainNode=o.createGain();this._nativeOscillatorNode=o.createOscillator();this._nativeGainNode.gain.value=1e-37;this._nativeOscillatorNode.connect(this._nativeGainNode).connect(o.destination);this._nativeOscillatorNode.start()}else{this._nativeGainNode=null;this._nativeOscillatorNode=null}this._state=null;if(o.state==="running"){this._state="suspended";const revokeState=()=>{this._state==="suspended"&&(this._state=null);o.removeEventListener("statechange",revokeState)};o.addEventListener("statechange",revokeState)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){if(this.state==="closed")return this._nativeAudioContext.close().then((()=>{throw e()}));this._state==="suspended"&&(this._state=null);return this._nativeAudioContext.close().then((()=>{if(this._nativeGainNode!==null&&this._nativeOscillatorNode!==null){this._nativeOscillatorNode.stop();this._nativeGainNode.disconnect();this._nativeOscillatorNode.disconnect()}deactivateAudioGraph(this)}))}resume(){return this._state==="suspended"?new Promise(((e,t)=>{const resolvePromise=()=>{this._nativeAudioContext.removeEventListener("statechange",resolvePromise);this._nativeAudioContext.state==="running"?e():this.resume().then(e,t)};this._nativeAudioContext.addEventListener("statechange",resolvePromise)})):this._nativeAudioContext.resume().catch((t=>{if(t===void 0||t.code===15)throw e();throw t}))}suspend(){return this._nativeAudioContext.suspend().catch((t=>{if(t===void 0)throw e();throw t}))}};const createMinimalBaseAudioContextConstructor=(e,t,n,o,r,s)=>class MinimalBaseAudioContext extends n{constructor(n,s){super(n);this._nativeContext=n;f.set(this,n);o(n)&&r.set(n,new Set);this._destination=new e(this,s);this._listener=t(this,n);this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(e){const t=typeof e==="function"?s(this,e):null;this._nativeContext.onstatechange=t;const n=this._nativeContext.onstatechange;this._onstatechange=n!==null&&n===t?e:n}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}};const testPromiseSupport=e=>{const t=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const n=e.decodeAudioData(t.buffer,(()=>{}));if(n===void 0)return false;n.catch((()=>{}));return true}catch{}return false};const F={numberOfChannels:1};const createMinimalOfflineAudioContextConstructor=(e,t,n,o,r)=>class MinimalOfflineAudioContext extends o{constructor(t){const{length:o,numberOfChannels:r,sampleRate:s}={...F,...t};const a=n(r,o,s);e(testPromiseSupport,(()=>testPromiseSupport(a)))||a.addEventListener("statechange",(()=>{let e=0;const delayStateChangeEvent=t=>{if(this._state==="running")if(e>0){a.removeEventListener("statechange",delayStateChangeEvent);t.stopImmediatePropagation();this._waitForThePromiseToSettle(t)}else e+=1};return delayStateChangeEvent})());super(a,r);this._length=o;this._nativeOfflineAudioContext=a;this._state=null}get length(){return this._nativeOfflineAudioContext.length===void 0?this._length:this._nativeOfflineAudioContext.length}get state(){return this._state===null?this._nativeOfflineAudioContext.state:this._state}startRendering(){if(this._state==="running")return Promise.reject(t());this._state="running";return r(this.destination,this._nativeOfflineAudioContext).finally((()=>{this._state=null;deactivateAudioGraph(this)}))}_waitForThePromiseToSettle(e){this._state===null?this._nativeOfflineAudioContext.dispatchEvent(e):setTimeout((()=>this._waitForThePromiseToSettle(e)))}};const createMonitorConnections=(e,t)=>(n,o,r)=>{const s=new Set;n.connect=(r=>(a,c=0,i=0)=>{const l=s.size===0;if(t(a)){r.call(n,a,c,i);e(s,[a,c,i],(e=>e[0]===a&&e[1]===c&&e[2]===i),true);l&&o();return a}r.call(n,a,c);e(s,[a,c],(e=>e[0]===a&&e[1]===c),true);l&&o()})(n.connect);n.disconnect=(e=>(o,a,c)=>{const i=s.size>0;if(o===void 0){e.apply(n);s.clear()}else if(typeof o==="number"){e.call(n,o);for(const e of s)e[1]===o&&s.delete(e)}else{t(o)?e.call(n,o,a,c):e.call(n,o,a);for(const e of s)e[0]!==o||a!==void 0&&e[1]!==a||c!==void 0&&e[2]!==c||s.delete(e)}const l=s.size===0;i&&l&&r()})(n.disconnect);return n};const assignNativeAudioNodeOption=(e,t,n)=>{const o=t[n];o!==void 0&&o!==e[n]&&(e[n]=o)};const assignNativeAudioNodeOptions=(e,t)=>{assignNativeAudioNodeOption(e,t,"channelCount");assignNativeAudioNodeOption(e,t,"channelCountMode");assignNativeAudioNodeOption(e,t,"channelInterpretation")};const testAnalyserNodeGetFloatTimeDomainDataMethodSupport=e=>typeof e.getFloatTimeDomainData==="function";const wrapAnalyserNodeGetFloatTimeDomainDataMethod=e=>{e.getFloatTimeDomainData=t=>{const n=new Uint8Array(t.length);e.getByteTimeDomainData(n);const o=Math.max(n.length,e.fftSize);for(let e=0;e<o;e+=1)t[e]=.0078125*(n[e]-128);return t}};const createNativeAnalyserNodeFactory=(e,t)=>(n,o)=>{const r=n.createAnalyser();assignNativeAudioNodeOptions(r,o);if(!(o.maxDecibels>o.minDecibels))throw t();assignNativeAudioNodeOption(r,o,"fftSize");assignNativeAudioNodeOption(r,o,"maxDecibels");assignNativeAudioNodeOption(r,o,"minDecibels");assignNativeAudioNodeOption(r,o,"smoothingTimeConstant");e(testAnalyserNodeGetFloatTimeDomainDataMethodSupport,(()=>testAnalyserNodeGetFloatTimeDomainDataMethodSupport(r)))||wrapAnalyserNodeGetFloatTimeDomainDataMethod(r);return r};const createNativeAudioBufferConstructor=e=>e===null?null:e.hasOwnProperty("AudioBuffer")?e.AudioBuffer:null;const assignNativeAudioNodeAudioParamValue=(e,t,n)=>{const o=t[n];o!==void 0&&o!==e[n].value&&(e[n].value=o)};const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls=e=>{e.start=(t=>{let n=false;return(o=0,r=0,s)=>{if(n)throw createInvalidStateError();t.call(e,o,r,s);n=true}})(e.start)};const wrapAudioScheduledSourceNodeStartMethodNegativeParameters=e=>{e.start=(t=>(n=0,o=0,r)=>{if(typeof r==="number"&&r<0||o<0||n<0)throw new RangeError("The parameters can't be negative.");t.call(e,n,o,r)})(e.start)};const wrapAudioScheduledSourceNodeStopMethodNegativeParameters=e=>{e.stop=(t=>(n=0)=>{if(n<0)throw new RangeError("The parameter can't be negative.");t.call(e,n)})(e.stop)};const createNativeAudioBufferSourceNodeFactory=(e,t,n,o,r,s,a,c,i,l,u)=>(d,h)=>{const f=d.createBufferSource();assignNativeAudioNodeOptions(f,h);assignNativeAudioNodeAudioParamValue(f,h,"playbackRate");assignNativeAudioNodeOption(f,h,"buffer");assignNativeAudioNodeOption(f,h,"loop");assignNativeAudioNodeOption(f,h,"loopEnd");assignNativeAudioNodeOption(f,h,"loopStart");t(n,(()=>n(d)))||wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(f);t(o,(()=>o(d)))||i(f);t(r,(()=>r(d)))||l(f,d);t(s,(()=>s(d)))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(f);t(a,(()=>a(d)))||u(f,d);t(c,(()=>c(d)))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(f);e(d,f);return f};const createNativeAudioContextConstructor=e=>e===null?null:e.hasOwnProperty("AudioContext")?e.AudioContext:e.hasOwnProperty("webkitAudioContext")?e.webkitAudioContext:null;const createNativeAudioDestinationNodeFactory=(e,t)=>(n,o,r)=>{const s=n.destination;if(s.channelCount!==o)try{s.channelCount=o}catch{}r&&s.channelCountMode!=="explicit"&&(s.channelCountMode="explicit");s.maxChannelCount===0&&Object.defineProperty(s,"maxChannelCount",{value:o});const a=e(n,{channelCount:o,channelCountMode:s.channelCountMode,channelInterpretation:s.channelInterpretation,gain:1});t(a,"channelCount",(e=>()=>e.call(a)),(e=>t=>{e.call(a,t);try{s.channelCount=t}catch(e){if(t>s.maxChannelCount)throw e}}));t(a,"channelCountMode",(e=>()=>e.call(a)),(e=>t=>{e.call(a,t);s.channelCountMode=t}));t(a,"channelInterpretation",(e=>()=>e.call(a)),(e=>t=>{e.call(a,t);s.channelInterpretation=t}));Object.defineProperty(a,"maxChannelCount",{get:()=>s.maxChannelCount});a.connect(s);return a};const createNativeAudioWorkletNodeConstructor=e=>e===null?null:e.hasOwnProperty("AudioWorkletNode")?e.AudioWorkletNode:null;const testClonabilityOfAudioWorkletNodeOptions=e=>{const{port1:t}=new MessageChannel;try{t.postMessage(e)}finally{t.close()}};const createNativeAudioWorkletNodeFactory=(e,t,n,o,r)=>(s,a,c,i,l,u)=>{if(c!==null)try{const t=new c(s,i,u);const o=new Map;let a=null;Object.defineProperties(t,{channelCount:{get:()=>u.channelCount,set:()=>{throw e()}},channelCountMode:{get:()=>"explicit",set:()=>{throw e()}},onprocessorerror:{get:()=>a,set:e=>{typeof a==="function"&&t.removeEventListener("processorerror",a);a=typeof e==="function"?e:null;typeof a==="function"&&t.addEventListener("processorerror",a)}}});t.addEventListener=(e=>(...n)=>{if(n[0]==="processorerror"){const e=typeof n[1]==="function"?n[1]:typeof n[1]==="object"&&n[1]!==null&&typeof n[1].handleEvent==="function"?n[1].handleEvent:null;if(e!==null){const t=o.get(n[1]);if(t!==void 0)n[1]=t;else{n[1]=t=>{if(t.type==="error"){Object.defineProperties(t,{type:{value:"processorerror"}});e(t)}else e(new ErrorEvent(n[0],{...t}))};o.set(e,n[1])}}}e.call(t,"error",n[1],n[2]);return e.call(t,...n)})(t.addEventListener);t.removeEventListener=(e=>(...n)=>{if(n[0]==="processorerror"){const e=o.get(n[1]);if(e!==void 0){o.delete(n[1]);n[1]=e}}e.call(t,"error",n[1],n[2]);return e.call(t,n[0],n[1],n[2])})(t.removeEventListener);if(u.numberOfOutputs!==0){const e=n(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});t.connect(e).connect(s.destination);const whenConnected=()=>e.disconnect();const whenDisconnected=()=>e.connect(s.destination);return r(t,whenConnected,whenDisconnected)}return t}catch(e){if(e.code===11)throw o();throw e}if(l===void 0)throw o();testClonabilityOfAudioWorkletNodeOptions(u);return t(s,a,l,u)};const computeBufferSize=(e,t)=>e===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(e*t)))));const cloneAudioWorkletNodeOptions=e=>new Promise(((t,n)=>{const{port1:o,port2:r}=new MessageChannel;o.onmessage=({data:e})=>{o.close();r.close();t(e)};o.onmessageerror=({data:e})=>{o.close();r.close();n(e)};r.postMessage(e)}));const createAudioWorkletProcessorPromise=async(e,t)=>{const n=await cloneAudioWorkletNodeOptions(t);return new e(n)};const createAudioWorkletProcessor=(e,t,n,o)=>{let r=g.get(e);if(r===void 0){r=new WeakMap;g.set(e,r)}const s=createAudioWorkletProcessorPromise(n,o);r.set(t,s);return s};const createNativeAudioWorkletNodeFakerFactory=(e,t,n,o,r,s,a,c,i,l,u,d,h)=>(f,p,m,v)=>{if(v.numberOfInputs===0&&v.numberOfOutputs===0)throw i();const g=Array.isArray(v.outputChannelCount)?v.outputChannelCount:Array.from(v.outputChannelCount);if(g.some((e=>e<1)))throw i();if(g.length!==v.numberOfOutputs)throw t();if(v.channelCountMode!=="explicit")throw i();const C=v.channelCount*v.numberOfInputs;const w=g.reduce(((e,t)=>e+t),0);const y=m.parameterDescriptors===void 0?0:m.parameterDescriptors.length;if(C+y>6||w>6)throw i();const _=new MessageChannel;const A=[];const O=[];for(let e=0;e<v.numberOfInputs;e+=1){A.push(a(f,{channelCount:v.channelCount,channelCountMode:v.channelCountMode,channelInterpretation:v.channelInterpretation,gain:1}));O.push(r(f,{channelCount:v.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:v.channelCount}))}const x=[];if(m.parameterDescriptors!==void 0)for(const{defaultValue:e,maxValue:t,minValue:n,name:o}of m.parameterDescriptors){const r=s(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:v.parameterData[o]!==void 0?v.parameterData[o]:e===void 0?0:e});Object.defineProperties(r.offset,{defaultValue:{get:()=>e===void 0?0:e},maxValue:{get:()=>t===void 0?b:t},minValue:{get:()=>n===void 0?M:n}});x.push(r)}const N=o(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,C+y)});const I=computeBufferSize(p,f.sampleRate);const E=c(f,I,C+y,Math.max(1,w));const S=r(f,{channelCount:Math.max(1,w),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,w)});const T=[];for(let e=0;e<v.numberOfOutputs;e+=1)T.push(o(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:g[e]}));for(let e=0;e<v.numberOfInputs;e+=1){A[e].connect(O[e]);for(let t=0;t<v.channelCount;t+=1)O[e].connect(N,t,e*v.channelCount+t)}const k=new ReadOnlyMap(m.parameterDescriptors===void 0?[]:m.parameterDescriptors.map((({name:e},t)=>{const n=x[t];n.connect(N,0,C+t);n.start(0);return[e,n.offset]})));N.connect(E);let D=v.channelInterpretation;let P=null;const R=v.numberOfOutputs===0?[E]:T;const F={get bufferSize(){return I},get channelCount(){return v.channelCount},set channelCount(e){throw n()},get channelCountMode(){return v.channelCountMode},set channelCountMode(e){throw n()},get channelInterpretation(){return D},set channelInterpretation(e){for(const t of A)t.channelInterpretation=e;D=e},get context(){return E.context},get inputs(){return A},get numberOfInputs(){return v.numberOfInputs},get numberOfOutputs(){return v.numberOfOutputs},get onprocessorerror(){return P},set onprocessorerror(e){typeof P==="function"&&F.removeEventListener("processorerror",P);P=typeof e==="function"?e:null;typeof P==="function"&&F.addEventListener("processorerror",P)},get parameters(){return k},get port(){return _.port2},addEventListener(...e){return E.addEventListener(e[0],e[1],e[2])},connect:e.bind(null,R),disconnect:l.bind(null,R),dispatchEvent(...e){return E.dispatchEvent(e[0])},removeEventListener(...e){return E.removeEventListener(e[0],e[1],e[2])}};const L=new Map;_.port1.addEventListener=(e=>(...t)=>{if(t[0]==="message"){const e=typeof t[1]==="function"?t[1]:typeof t[1]==="object"&&t[1]!==null&&typeof t[1].handleEvent==="function"?t[1].handleEvent:null;if(e!==null){const n=L.get(t[1]);if(n!==void 0)t[1]=n;else{t[1]=t=>{u(f.currentTime,f.sampleRate,(()=>e(t)))};L.set(e,t[1])}}}return e.call(_.port1,t[0],t[1],t[2])})(_.port1.addEventListener);_.port1.removeEventListener=(e=>(...t)=>{if(t[0]==="message"){const e=L.get(t[1]);if(e!==void 0){L.delete(t[1]);t[1]=e}}return e.call(_.port1,t[0],t[1],t[2])})(_.port1.removeEventListener);let W=null;Object.defineProperty(_.port1,"onmessage",{get:()=>W,set:e=>{typeof W==="function"&&_.port1.removeEventListener("message",W);W=typeof e==="function"?e:null;if(typeof W==="function"){_.port1.addEventListener("message",W);_.port1.start()}}});m.prototype.port=_.port1;let B=null;const V=createAudioWorkletProcessor(f,F,m,v);V.then((e=>B=e));const j=createNestedArrays(v.numberOfInputs,v.channelCount);const q=createNestedArrays(v.numberOfOutputs,g);const X=m.parameterDescriptors===void 0?[]:m.parameterDescriptors.reduce(((e,{name:t})=>({...e,[t]:new Float32Array(128)})),{});let Y=true;const disconnectOutputsGraph=()=>{v.numberOfOutputs>0&&E.disconnect(S);for(let e=0,t=0;e<v.numberOfOutputs;e+=1){const n=T[e];for(let o=0;o<g[e];o+=1)S.disconnect(n,t+o,o);t+=g[e]}};const G=new Map;E.onaudioprocess=({inputBuffer:e,outputBuffer:t})=>{if(B!==null){const n=d(F);for(let o=0;o<I;o+=128){for(let t=0;t<v.numberOfInputs;t+=1)for(let n=0;n<v.channelCount;n+=1)copyFromChannel(e,j[t],n,n,o);m.parameterDescriptors!==void 0&&m.parameterDescriptors.forEach((({name:t},n)=>{copyFromChannel(e,X,t,C+n,o)}));for(let e=0;e<v.numberOfInputs;e+=1)for(let t=0;t<g[e];t+=1)q[e][t].byteLength===0&&(q[e][t]=new Float32Array(128));try{const e=j.map(((e,t)=>{const o=n[t];if(o.size>0){G.set(t,I/128);return e}const r=G.get(t);if(r===void 0)return[];e.every((e=>e.every((e=>e===0))))&&(r===1?G.delete(t):G.set(t,r-1));return e}));const r=u(f.currentTime+o/f.sampleRate,f.sampleRate,(()=>B.process(e,q,X)));Y=r;for(let e=0,n=0;e<v.numberOfOutputs;e+=1){for(let r=0;r<g[e];r+=1)copyToChannel(t,q[e],r,n+r,o);n+=g[e]}}catch(e){Y=false;F.dispatchEvent(new ErrorEvent("processorerror",{colno:e.colno,filename:e.filename,lineno:e.lineno,message:e.message}))}if(!Y){for(let e=0;e<v.numberOfInputs;e+=1){A[e].disconnect(O[e]);for(let t=0;t<v.channelCount;t+=1)O[o].disconnect(N,t,e*v.channelCount+t)}if(m.parameterDescriptors!==void 0){const e=m.parameterDescriptors.length;for(let t=0;t<e;t+=1){const e=x[t];e.disconnect(N,0,C+t);e.stop()}}N.disconnect(E);E.onaudioprocess=null;Z?disconnectOutputsGraph():disconnectFakeGraph();break}}}};let Z=false;const z=a(f,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});const connectFakeGraph=()=>E.connect(z).connect(f.destination);const disconnectFakeGraph=()=>{E.disconnect(z);z.disconnect()};const whenConnected=()=>{if(Y){disconnectFakeGraph();v.numberOfOutputs>0&&E.connect(S);for(let e=0,t=0;e<v.numberOfOutputs;e+=1){const n=T[e];for(let o=0;o<g[e];o+=1)S.connect(n,t+o,o);t+=g[e]}}Z=true};const whenDisconnected=()=>{if(Y){connectFakeGraph();disconnectOutputsGraph()}Z=false};connectFakeGraph();return h(F,whenConnected,whenDisconnected)};const createNativeBiquadFilterNode=(e,t)=>{const n=e.createBiquadFilter();assignNativeAudioNodeOptions(n,t);assignNativeAudioNodeAudioParamValue(n,t,"Q");assignNativeAudioNodeAudioParamValue(n,t,"detune");assignNativeAudioNodeAudioParamValue(n,t,"frequency");assignNativeAudioNodeAudioParamValue(n,t,"gain");assignNativeAudioNodeOption(n,t,"type");return n};const createNativeChannelMergerNodeFactory=(e,t)=>(n,o)=>{const r=n.createChannelMerger(o.numberOfInputs);e!==null&&e.name==="webkitAudioContext"&&t(n,r);assignNativeAudioNodeOptions(r,o);return r};const wrapChannelSplitterNode=e=>{const t=e.numberOfOutputs;Object.defineProperty(e,"channelCount",{get:()=>t,set:e=>{if(e!==t)throw createInvalidStateError()}});Object.defineProperty(e,"channelCountMode",{get:()=>"explicit",set:e=>{if(e!=="explicit")throw createInvalidStateError()}});Object.defineProperty(e,"channelInterpretation",{get:()=>"discrete",set:e=>{if(e!=="discrete")throw createInvalidStateError()}})};const createNativeChannelSplitterNode=(e,t)=>{const n=e.createChannelSplitter(t.numberOfOutputs);assignNativeAudioNodeOptions(n,t);wrapChannelSplitterNode(n);return n};const createNativeConstantSourceNodeFactory=(e,t,n,o,r)=>(s,a)=>{if(s.createConstantSource===void 0)return n(s,a);const c=s.createConstantSource();assignNativeAudioNodeOptions(c,a);assignNativeAudioNodeAudioParamValue(c,a,"offset");t(o,(()=>o(s)))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(c);t(r,(()=>r(s)))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(c);e(s,c);return c};const interceptConnections=(e,t)=>{e.connect=t.connect.bind(t);e.disconnect=t.disconnect.bind(t);return e};const createNativeConstantSourceNodeFakerFactory=(e,t,n,o)=>(r,{offset:s,...a})=>{const c=r.createBuffer(1,2,44100);const i=t(r,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:false,loopEnd:0,loopStart:0,playbackRate:1});const l=n(r,{...a,gain:s});const u=c.getChannelData(0);u[0]=1;u[1]=1;i.buffer=c;i.loop=true;const d={get bufferSize(){},get channelCount(){return l.channelCount},set channelCount(e){l.channelCount=e},get channelCountMode(){return l.channelCountMode},set channelCountMode(e){l.channelCountMode=e},get channelInterpretation(){return l.channelInterpretation},set channelInterpretation(e){l.channelInterpretation=e},get context(){return l.context},get inputs(){return[]},get numberOfInputs(){return i.numberOfInputs},get numberOfOutputs(){return l.numberOfOutputs},get offset(){return l.gain},get onended(){return i.onended},set onended(e){i.onended=e},addEventListener(...e){return i.addEventListener(e[0],e[1],e[2])},dispatchEvent(...e){return i.dispatchEvent(e[0])},removeEventListener(...e){return i.removeEventListener(e[0],e[1],e[2])},start(e=0){i.start.call(i,e)},stop(e=0){i.stop.call(i,e)}};const whenConnected=()=>i.connect(l);const whenDisconnected=()=>i.disconnect(l);e(r,i);return o(interceptConnections(d,l),whenConnected,whenDisconnected)};const createNativeConvolverNodeFactory=(e,t)=>(n,o)=>{const r=n.createConvolver();assignNativeAudioNodeOptions(r,o);o.disableNormalization===r.normalize&&(r.normalize=!o.disableNormalization);assignNativeAudioNodeOption(r,o,"buffer");if(o.channelCount>2)throw e();t(r,"channelCount",(e=>()=>e.call(r)),(t=>n=>{if(n>2)throw e();return t.call(r,n)}));if(o.channelCountMode==="max")throw e();t(r,"channelCountMode",(e=>()=>e.call(r)),(t=>n=>{if(n==="max")throw e();return t.call(r,n)}));return r};const createNativeDelayNode=(e,t)=>{const n=e.createDelay(t.maxDelayTime);assignNativeAudioNodeOptions(n,t);assignNativeAudioNodeAudioParamValue(n,t,"delayTime");return n};const createNativeDynamicsCompressorNodeFactory=e=>(t,n)=>{const o=t.createDynamicsCompressor();assignNativeAudioNodeOptions(o,n);if(n.channelCount>2)throw e();if(n.channelCountMode==="max")throw e();assignNativeAudioNodeAudioParamValue(o,n,"attack");assignNativeAudioNodeAudioParamValue(o,n,"knee");assignNativeAudioNodeAudioParamValue(o,n,"ratio");assignNativeAudioNodeAudioParamValue(o,n,"release");assignNativeAudioNodeAudioParamValue(o,n,"threshold");return o};const createNativeGainNode=(e,t)=>{const n=e.createGain();assignNativeAudioNodeOptions(n,t);assignNativeAudioNodeAudioParamValue(n,t,"gain");return n};const createNativeIIRFilterNodeFactory=e=>(t,n,o)=>{if(t.createIIRFilter===void 0)return e(t,n,o);const r=t.createIIRFilter(o.feedforward,o.feedback);assignNativeAudioNodeOptions(r,o);return r};function divide(e,t){const n=t[0]*t[0]+t[1]*t[1];return[(e[0]*t[0]+e[1]*t[1])/n,(e[1]*t[0]-e[0]*t[1])/n]}function multiply(e,t){return[e[0]*t[0]-e[1]*t[1],e[0]*t[1]+e[1]*t[0]]}function evaluatePolynomial(e,t){let n=[0,0];for(let o=e.length-1;o>=0;o-=1){n=multiply(n,t);n[0]+=e[o]}return n}const createNativeIIRFilterNodeFakerFactory=(e,t,n,o)=>(r,s,{channelCount:a,channelCountMode:c,channelInterpretation:i,feedback:l,feedforward:u})=>{const d=computeBufferSize(s,r.sampleRate);const h=l instanceof Float64Array?l:new Float64Array(l);const f=u instanceof Float64Array?u:new Float64Array(u);const p=h.length;const m=f.length;const v=Math.min(p,m);if(p===0||p>20)throw o();if(h[0]===0)throw t();if(m===0||m>20)throw o();if(f[0]===0)throw t();if(h[0]!==1){for(let e=0;e<m;e+=1)f[e]/=h[0];for(let e=1;e<p;e+=1)h[e]/=h[0]}const g=n(r,d,a,a);g.channelCount=a;g.channelCountMode=c;g.channelInterpretation=i;const C=32;const w=[];const y=[];const _=[];for(let e=0;e<a;e+=1){w.push(0);const e=new Float32Array(C);const t=new Float32Array(C);e.fill(0);t.fill(0);y.push(e);_.push(t)}g.onaudioprocess=e=>{const t=e.inputBuffer;const n=e.outputBuffer;const o=t.numberOfChannels;for(let e=0;e<o;e+=1){const o=t.getChannelData(e);const r=n.getChannelData(e);w[e]=filterBuffer(h,p,f,m,v,y[e],_[e],w[e],C,o,r)}};const M=r.sampleRate/2;const b={get bufferSize(){return d},get channelCount(){return g.channelCount},set channelCount(e){g.channelCount=e},get channelCountMode(){return g.channelCountMode},set channelCountMode(e){g.channelCountMode=e},get channelInterpretation(){return g.channelInterpretation},set channelInterpretation(e){g.channelInterpretation=e},get context(){return g.context},get inputs(){return[g]},get numberOfInputs(){return g.numberOfInputs},get numberOfOutputs(){return g.numberOfOutputs},addEventListener(...e){return g.addEventListener(e[0],e[1],e[2])},dispatchEvent(...e){return g.dispatchEvent(e[0])},getFrequencyResponse(t,n,o){if(t.length!==n.length||n.length!==o.length)throw e();const r=t.length;for(let e=0;e<r;e+=1){const r=-Math.PI*(t[e]/M);const s=[Math.cos(r),Math.sin(r)];const a=evaluatePolynomial(f,s);const c=evaluatePolynomial(h,s);const i=divide(a,c);n[e]=Math.sqrt(i[0]*i[0]+i[1]*i[1]);o[e]=Math.atan2(i[1],i[0])}},removeEventListener(...e){return g.removeEventListener(e[0],e[1],e[2])}};return interceptConnections(b,g)};const createNativeMediaElementAudioSourceNode=(e,t)=>e.createMediaElementSource(t.mediaElement);const createNativeMediaStreamAudioDestinationNode=(e,t)=>{const n=e.createMediaStreamDestination();assignNativeAudioNodeOptions(n,t);n.numberOfOutputs===1&&Object.defineProperty(n,"numberOfOutputs",{get:()=>0});return n};const createNativeMediaStreamAudioSourceNode=(e,{mediaStream:t})=>{const n=t.getAudioTracks();n.sort(((e,t)=>e.id<t.id?-1:e.id>t.id?1:0));const o=n.slice(0,1);const r=e.createMediaStreamSource(new MediaStream(o));Object.defineProperty(r,"mediaStream",{value:t});return r};const createNativeMediaStreamTrackAudioSourceNodeFactory=(e,t)=>(n,{mediaStreamTrack:o})=>{if(typeof n.createMediaStreamTrackSource==="function")return n.createMediaStreamTrackSource(o);const r=new MediaStream([o]);const s=n.createMediaStreamSource(r);if(o.kind!=="audio")throw e();if(t(n))throw new TypeError;return s};const createNativeOfflineAudioContextConstructor=e=>e===null?null:e.hasOwnProperty("OfflineAudioContext")?e.OfflineAudioContext:e.hasOwnProperty("webkitOfflineAudioContext")?e.webkitOfflineAudioContext:null;const createNativeOscillatorNodeFactory=(e,t,n,o,r,s)=>(a,c)=>{const i=a.createOscillator();assignNativeAudioNodeOptions(i,c);assignNativeAudioNodeAudioParamValue(i,c,"detune");assignNativeAudioNodeAudioParamValue(i,c,"frequency");c.periodicWave!==void 0?i.setPeriodicWave(c.periodicWave):assignNativeAudioNodeOption(i,c,"type");t(n,(()=>n(a)))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(i);t(o,(()=>o(a)))||s(i,a);t(r,(()=>r(a)))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(i);e(a,i);return i};const createNativePannerNodeFactory=e=>(t,n)=>{const o=t.createPanner();if(o.orientationX===void 0)return e(t,n);assignNativeAudioNodeOptions(o,n);assignNativeAudioNodeAudioParamValue(o,n,"orientationX");assignNativeAudioNodeAudioParamValue(o,n,"orientationY");assignNativeAudioNodeAudioParamValue(o,n,"orientationZ");assignNativeAudioNodeAudioParamValue(o,n,"positionX");assignNativeAudioNodeAudioParamValue(o,n,"positionY");assignNativeAudioNodeAudioParamValue(o,n,"positionZ");assignNativeAudioNodeOption(o,n,"coneInnerAngle");assignNativeAudioNodeOption(o,n,"coneOuterAngle");assignNativeAudioNodeOption(o,n,"coneOuterGain");assignNativeAudioNodeOption(o,n,"distanceModel");assignNativeAudioNodeOption(o,n,"maxDistance");assignNativeAudioNodeOption(o,n,"panningModel");assignNativeAudioNodeOption(o,n,"refDistance");assignNativeAudioNodeOption(o,n,"rolloffFactor");return o};const createNativePannerNodeFakerFactory=(e,t,n,o,r,s,a,c,i,l)=>(u,{coneInnerAngle:d,coneOuterAngle:h,coneOuterGain:f,distanceModel:p,maxDistance:m,orientationX:v,orientationY:g,orientationZ:C,panningModel:w,positionX:y,positionY:_,positionZ:M,refDistance:b,rolloffFactor:A,...O})=>{const x=u.createPanner();if(O.channelCount>2)throw a();if(O.channelCountMode==="max")throw a();assignNativeAudioNodeOptions(x,O);const N={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"};const I=n(u,{...N,channelInterpretation:"speakers",numberOfInputs:6});const E=o(u,{...O,gain:1});const S=o(u,{...N,gain:1});const T=o(u,{...N,gain:0});const k=o(u,{...N,gain:0});const D=o(u,{...N,gain:0});const P=o(u,{...N,gain:0});const R=o(u,{...N,gain:0});const F=r(u,256,6,1);const L=s(u,{...N,curve:new Float32Array([1,1]),oversample:"none"});let W=[v,g,C];let B=[y,_,M];const V=new Float32Array(1);F.onaudioprocess=({inputBuffer:e})=>{const t=[i(e,V,0),i(e,V,1),i(e,V,2)];if(t.some(((e,t)=>e!==W[t]))){x.setOrientation(...t);W=t}const n=[i(e,V,3),i(e,V,4),i(e,V,5)];if(n.some(((e,t)=>e!==B[t]))){x.setPosition(...n);B=n}};Object.defineProperty(T.gain,"defaultValue",{get:()=>0});Object.defineProperty(k.gain,"defaultValue",{get:()=>0});Object.defineProperty(D.gain,"defaultValue",{get:()=>0});Object.defineProperty(P.gain,"defaultValue",{get:()=>0});Object.defineProperty(R.gain,"defaultValue",{get:()=>0});const j={get bufferSize(){},get channelCount(){return x.channelCount},set channelCount(e){if(e>2)throw a();E.channelCount=e;x.channelCount=e},get channelCountMode(){return x.channelCountMode},set channelCountMode(e){if(e==="max")throw a();E.channelCountMode=e;x.channelCountMode=e},get channelInterpretation(){return x.channelInterpretation},set channelInterpretation(e){E.channelInterpretation=e;x.channelInterpretation=e},get coneInnerAngle(){return x.coneInnerAngle},set coneInnerAngle(e){x.coneInnerAngle=e},get coneOuterAngle(){return x.coneOuterAngle},set coneOuterAngle(e){x.coneOuterAngle=e},get coneOuterGain(){return x.coneOuterGain},set coneOuterGain(e){if(e<0||e>1)throw t();x.coneOuterGain=e},get context(){return x.context},get distanceModel(){return x.distanceModel},set distanceModel(e){x.distanceModel=e},get inputs(){return[E]},get maxDistance(){return x.maxDistance},set maxDistance(e){if(e<0)throw new RangeError;x.maxDistance=e},get numberOfInputs(){return x.numberOfInputs},get numberOfOutputs(){return x.numberOfOutputs},get orientationX(){return S.gain},get orientationY(){return T.gain},get orientationZ(){return k.gain},get panningModel(){return x.panningModel},set panningModel(e){x.panningModel=e},get positionX(){return D.gain},get positionY(){return P.gain},get positionZ(){return R.gain},get refDistance(){return x.refDistance},set refDistance(e){if(e<0)throw new RangeError;x.refDistance=e},get rolloffFactor(){return x.rolloffFactor},set rolloffFactor(e){if(e<0)throw new RangeError;x.rolloffFactor=e},addEventListener(...e){return E.addEventListener(e[0],e[1],e[2])},dispatchEvent(...e){return E.dispatchEvent(e[0])},removeEventListener(...e){return E.removeEventListener(e[0],e[1],e[2])}};d!==j.coneInnerAngle&&(j.coneInnerAngle=d);h!==j.coneOuterAngle&&(j.coneOuterAngle=h);f!==j.coneOuterGain&&(j.coneOuterGain=f);p!==j.distanceModel&&(j.distanceModel=p);m!==j.maxDistance&&(j.maxDistance=m);v!==j.orientationX.value&&(j.orientationX.value=v);g!==j.orientationY.value&&(j.orientationY.value=g);C!==j.orientationZ.value&&(j.orientationZ.value=C);w!==j.panningModel&&(j.panningModel=w);y!==j.positionX.value&&(j.positionX.value=y);_!==j.positionY.value&&(j.positionY.value=_);M!==j.positionZ.value&&(j.positionZ.value=M);b!==j.refDistance&&(j.refDistance=b);A!==j.rolloffFactor&&(j.rolloffFactor=A);W[0]===1&&W[1]===0&&W[2]===0||x.setOrientation(...W);B[0]===0&&B[1]===0&&B[2]===0||x.setPosition(...B);const whenConnected=()=>{E.connect(x);e(E,L,0,0);L.connect(S).connect(I,0,0);L.connect(T).connect(I,0,1);L.connect(k).connect(I,0,2);L.connect(D).connect(I,0,3);L.connect(P).connect(I,0,4);L.connect(R).connect(I,0,5);I.connect(F).connect(u.destination)};const whenDisconnected=()=>{E.disconnect(x);c(E,L,0,0);L.disconnect(S);S.disconnect(I);L.disconnect(T);T.disconnect(I);L.disconnect(k);k.disconnect(I);L.disconnect(D);D.disconnect(I);L.disconnect(P);P.disconnect(I);L.disconnect(R);R.disconnect(I);I.disconnect(F);F.disconnect(u.destination)};return l(interceptConnections(j,x),whenConnected,whenDisconnected)};const createNativePeriodicWaveFactory=e=>(t,{disableNormalization:n,imag:o,real:r})=>{const s=o instanceof Float32Array?o:new Float32Array(o);const a=r instanceof Float32Array?r:new Float32Array(r);const c=t.createPeriodicWave(a,s,{disableNormalization:n});if(Array.from(o).length<2)throw e();return c};const createNativeScriptProcessorNode=(e,t,n,o)=>e.createScriptProcessor(t,n,o);const createNativeStereoPannerNodeFactory=(e,t)=>(n,o)=>{const r=o.channelCountMode;if(r==="clamped-max")throw t();if(n.createStereoPanner===void 0)return e(n,o);const s=n.createStereoPanner();assignNativeAudioNodeOptions(s,o);assignNativeAudioNodeAudioParamValue(s,o,"pan");Object.defineProperty(s,"channelCountMode",{get:()=>r,set:e=>{if(e!==r)throw t()}});return s};const createNativeStereoPannerNodeFakerFactory=(e,t,n,o,r,s)=>{const a=16385;const c=new Float32Array([1,1]);const i=Math.PI/2;const l={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"};const u={...l,oversample:"none"};const buildInternalGraphForMono=(e,t,r,s)=>{const d=new Float32Array(a);const h=new Float32Array(a);for(let e=0;e<a;e+=1){const t=e/(a-1)*i;d[e]=Math.cos(t);h[e]=Math.sin(t)}const f=n(e,{...l,gain:0});const p=o(e,{...u,curve:d});const m=o(e,{...u,curve:c});const v=n(e,{...l,gain:0});const g=o(e,{...u,curve:h});return{connectGraph(){t.connect(f);t.connect(m.inputs===void 0?m:m.inputs[0]);t.connect(v);m.connect(r);r.connect(p.inputs===void 0?p:p.inputs[0]);r.connect(g.inputs===void 0?g:g.inputs[0]);p.connect(f.gain);g.connect(v.gain);f.connect(s,0,0);v.connect(s,0,1)},disconnectGraph(){t.disconnect(f);t.disconnect(m.inputs===void 0?m:m.inputs[0]);t.disconnect(v);m.disconnect(r);r.disconnect(p.inputs===void 0?p:p.inputs[0]);r.disconnect(g.inputs===void 0?g:g.inputs[0]);p.disconnect(f.gain);g.disconnect(v.gain);f.disconnect(s,0,0);v.disconnect(s,0,1)}}};const buildInternalGraphForStereo=(e,r,s,d)=>{const h=new Float32Array(a);const f=new Float32Array(a);const p=new Float32Array(a);const m=new Float32Array(a);const v=Math.floor(a/2);for(let e=0;e<a;e+=1)if(e>v){const t=(e-v)/(a-1-v)*i;h[e]=Math.cos(t);f[e]=Math.sin(t);p[e]=0;m[e]=1}else{const t=e/(a-1-v)*i;h[e]=1;f[e]=0;p[e]=Math.cos(t);m[e]=Math.sin(t)}const g=t(e,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2});const C=n(e,{...l,gain:0});const w=o(e,{...u,curve:h});const y=n(e,{...l,gain:0});const _=o(e,{...u,curve:f});const M=o(e,{...u,curve:c});const b=n(e,{...l,gain:0});const A=o(e,{...u,curve:p});const O=n(e,{...l,gain:0});const x=o(e,{...u,curve:m});return{connectGraph(){r.connect(g);r.connect(M.inputs===void 0?M:M.inputs[0]);g.connect(C,0);g.connect(y,0);g.connect(b,1);g.connect(O,1);M.connect(s);s.connect(w.inputs===void 0?w:w.inputs[0]);s.connect(_.inputs===void 0?_:_.inputs[0]);s.connect(A.inputs===void 0?A:A.inputs[0]);s.connect(x.inputs===void 0?x:x.inputs[0]);w.connect(C.gain);_.connect(y.gain);A.connect(b.gain);x.connect(O.gain);C.connect(d,0,0);b.connect(d,0,0);y.connect(d,0,1);O.connect(d,0,1)},disconnectGraph(){r.disconnect(g);r.disconnect(M.inputs===void 0?M:M.inputs[0]);g.disconnect(C,0);g.disconnect(y,0);g.disconnect(b,1);g.disconnect(O,1);M.disconnect(s);s.disconnect(w.inputs===void 0?w:w.inputs[0]);s.disconnect(_.inputs===void 0?_:_.inputs[0]);s.disconnect(A.inputs===void 0?A:A.inputs[0]);s.disconnect(x.inputs===void 0?x:x.inputs[0]);w.disconnect(C.gain);_.disconnect(y.gain);A.disconnect(b.gain);x.disconnect(O.gain);C.disconnect(d,0,0);b.disconnect(d,0,0);y.disconnect(d,0,1);O.disconnect(d,0,1)}}};const buildInternalGraph=(e,t,n,o,s)=>{if(t===1)return buildInternalGraphForMono(e,n,o,s);if(t===2)return buildInternalGraphForStereo(e,n,o,s);throw r()};return(t,{channelCount:o,channelCountMode:a,pan:c,...i})=>{if(a==="max")throw r();const l=e(t,{...i,channelCount:1,channelCountMode:a,numberOfInputs:2});const u=n(t,{...i,channelCount:o,channelCountMode:a,gain:1});const d=n(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:c});let{connectGraph:h,disconnectGraph:f}=buildInternalGraph(t,o,u,d,l);Object.defineProperty(d.gain,"defaultValue",{get:()=>0});Object.defineProperty(d.gain,"maxValue",{get:()=>1});Object.defineProperty(d.gain,"minValue",{get:()=>-1});const p={get bufferSize(){},get channelCount(){return u.channelCount},set channelCount(e){if(u.channelCount!==e){m&&f();({connectGraph:h,disconnectGraph:f}=buildInternalGraph(t,e,u,d,l));m&&h()}u.channelCount=e},get channelCountMode(){return u.channelCountMode},set channelCountMode(e){if(e==="clamped-max"||e==="max")throw r();u.channelCountMode=e},get channelInterpretation(){return u.channelInterpretation},set channelInterpretation(e){u.channelInterpretation=e},get context(){return u.context},get inputs(){return[u]},get numberOfInputs(){return u.numberOfInputs},get numberOfOutputs(){return u.numberOfOutputs},get pan(){return d.gain},addEventListener(...e){return u.addEventListener(e[0],e[1],e[2])},dispatchEvent(...e){return u.dispatchEvent(e[0])},removeEventListener(...e){return u.removeEventListener(e[0],e[1],e[2])}};let m=false;const whenConnected=()=>{h();m=true};const whenDisconnected=()=>{f();m=false};return s(interceptConnections(p,l),whenConnected,whenDisconnected)}};const createNativeWaveShaperNodeFactory=(e,t,n,o,r,s,a)=>(c,i)=>{const l=c.createWaveShaper();if(s!==null&&s.name==="webkitAudioContext"&&c.createGain().gain.automationRate===void 0)return n(c,i);assignNativeAudioNodeOptions(l,i);const u=i.curve===null||i.curve instanceof Float32Array?i.curve:new Float32Array(i.curve);if(u!==null&&u.length<2)throw t();assignNativeAudioNodeOption(l,{curve:u},"curve");assignNativeAudioNodeOption(l,i,"oversample");let d=null;let h=false;a(l,"curve",(e=>()=>e.call(l)),(t=>n=>{t.call(l,n);if(h)if(o(n)&&d===null)d=e(c,l);else if(!o(n)&&d!==null){d();d=null}return n}));const whenConnected=()=>{h=true;o(l.curve)&&(d=e(c,l))};const whenDisconnected=()=>{h=false;if(d!==null){d();d=null}};return r(l,whenConnected,whenDisconnected)};const createNativeWaveShaperNodeFakerFactory=(e,t,n,o,r)=>(s,{curve:a,oversample:c,...i})=>{const l=s.createWaveShaper();const u=s.createWaveShaper();assignNativeAudioNodeOptions(l,i);assignNativeAudioNodeOptions(u,i);const d=n(s,{...i,gain:1});const h=n(s,{...i,gain:-1});const f=n(s,{...i,gain:1});const p=n(s,{...i,gain:-1});let m=null;let v=false;let g=null;const C={get bufferSize(){},get channelCount(){return l.channelCount},set channelCount(e){d.channelCount=e;h.channelCount=e;l.channelCount=e;f.channelCount=e;u.channelCount=e;p.channelCount=e},get channelCountMode(){return l.channelCountMode},set channelCountMode(e){d.channelCountMode=e;h.channelCountMode=e;l.channelCountMode=e;f.channelCountMode=e;u.channelCountMode=e;p.channelCountMode=e},get channelInterpretation(){return l.channelInterpretation},set channelInterpretation(e){d.channelInterpretation=e;h.channelInterpretation=e;l.channelInterpretation=e;f.channelInterpretation=e;u.channelInterpretation=e;p.channelInterpretation=e},get context(){return l.context},get curve(){return g},set curve(n){if(n!==null&&n.length<2)throw t();if(n===null){l.curve=n;u.curve=n}else{const e=n.length;const t=new Float32Array(e+2-e%2);const o=new Float32Array(e+2-e%2);t[0]=n[0];o[0]=-n[e-1];const r=Math.ceil((e+1)/2);const s=(e+1)/2-1;for(let a=1;a<r;a+=1){const c=a/r*s;const i=Math.floor(c);const l=Math.ceil(c);t[a]=i===l?n[i]:(1-(c-i))*n[i]+(1-(l-c))*n[l];o[a]=i===l?-n[e-1-i]:-(1-(c-i))*n[e-1-i]-(1-(l-c))*n[e-1-l]}t[r]=e%2===1?n[r-1]:(n[r-2]+n[r-1])/2;l.curve=t;u.curve=o}g=n;if(v)if(o(g)&&m===null)m=e(s,d);else if(m!==null){m();m=null}},get inputs(){return[d]},get numberOfInputs(){return l.numberOfInputs},get numberOfOutputs(){return l.numberOfOutputs},get oversample(){return l.oversample},set oversample(e){l.oversample=e;u.oversample=e},addEventListener(...e){return d.addEventListener(e[0],e[1],e[2])},dispatchEvent(...e){return d.dispatchEvent(e[0])},removeEventListener(...e){return d.removeEventListener(e[0],e[1],e[2])}};a!==null&&(C.curve=a instanceof Float32Array?a:new Float32Array(a));c!==C.oversample&&(C.oversample=c);const whenConnected=()=>{d.connect(l).connect(f);d.connect(h).connect(u).connect(p).connect(f);v=true;o(g)&&(m=e(s,d))};const whenDisconnected=()=>{d.disconnect(l);l.disconnect(f);d.disconnect(h);h.disconnect(u);u.disconnect(p);p.disconnect(f);v=false;if(m!==null){m();m=null}};return r(interceptConnections(C,f),whenConnected,whenDisconnected)};const createNotSupportedError=()=>new DOMException("","NotSupportedError");const L={numberOfChannels:1};const createOfflineAudioContextConstructor=(e,t,n,o,r)=>class OfflineAudioContext extends e{constructor(e,n,r){let s;if(typeof e==="number"&&n!==void 0&&r!==void 0)s={length:n,numberOfChannels:e,sampleRate:r};else{if(typeof e!=="object")throw new Error("The given parameters are not valid.");s=e}const{length:a,numberOfChannels:c,sampleRate:i}={...L,...s};const l=o(c,a,i);t(testPromiseSupport,(()=>testPromiseSupport(l)))||l.addEventListener("statechange",(()=>{let e=0;const delayStateChangeEvent=t=>{if(this._state==="running")if(e>0){l.removeEventListener("statechange",delayStateChangeEvent);t.stopImmediatePropagation();this._waitForThePromiseToSettle(t)}else e+=1};return delayStateChangeEvent})());super(l,c);this._length=a;this._nativeOfflineAudioContext=l;this._state=null}get length(){return this._nativeOfflineAudioContext.length===void 0?this._length:this._nativeOfflineAudioContext.length}get state(){return this._state===null?this._nativeOfflineAudioContext.state:this._state}startRendering(){if(this._state==="running")return Promise.reject(n());this._state="running";return r(this.destination,this._nativeOfflineAudioContext).finally((()=>{this._state=null;deactivateAudioGraph(this)}))}_waitForThePromiseToSettle(e){this._state===null?this._nativeOfflineAudioContext.dispatchEvent(e):setTimeout((()=>this._waitForThePromiseToSettle(e)))}};const W={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"};const createOscillatorNodeConstructor=(e,t,n,o,r,s,a)=>class OscillatorNode extends e{constructor(e,a){const c=r(e);const i={...W,...a};const l=n(c,i);const u=s(c);const d=u?o():null;const h=e.sampleRate/2;super(e,false,l,d);this._detune=t(this,u,l.detune,153600,-153600);this._frequency=t(this,u,l.frequency,h,-h);this._nativeOscillatorNode=l;this._onended=null;this._oscillatorNodeRenderer=d;this._oscillatorNodeRenderer!==null&&i.periodicWave!==void 0&&(this._oscillatorNodeRenderer.periodicWave=i.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(e){const t=typeof e==="function"?a(this,e):null;this._nativeOscillatorNode.onended=t;const n=this._nativeOscillatorNode.onended;this._onended=n!==null&&n===t?e:n}get type(){return this._nativeOscillatorNode.type}set type(e){this._nativeOscillatorNode.type=e;this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(e){this._nativeOscillatorNode.setPeriodicWave(e);this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=e)}start(e=0){this._nativeOscillatorNode.start(e);this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.start=e);if(this.context.state!=="closed"){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeOscillatorNode.removeEventListener("ended",resetInternalStateToPassive);isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeOscillatorNode.addEventListener("ended",resetInternalStateToPassive)}}stop(e=0){this._nativeOscillatorNode.stop(e);this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.stop=e)}};const createOscillatorNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;let a=null;let c=null;let i=null;const createOscillatorNode=async(l,u)=>{let d=n(l);const h=isOwnedByContext(d,u);if(!h){const e={channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,detune:d.detune.value,frequency:d.frequency.value,periodicWave:a===null?void 0:a,type:d.type};d=t(u,e);c!==null&&d.start(c);i!==null&&d.stop(i)}s.set(u,d);if(h){await e(u,l.detune,d.detune);await e(u,l.frequency,d.frequency)}else{await o(u,l.detune,d.detune);await o(u,l.frequency,d.frequency)}await r(l,u,d);return d};return{set periodicWave(e){a=e},set start(e){c=e},set stop(e){i=e},render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createOscillatorNode(e,t)}}};const B={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1};const createPannerNodeConstructor=(e,t,n,o,r,s,a)=>class PannerNode extends e{constructor(e,c){const i=r(e);const l={...B,...c};const u=n(i,l);const d=s(i);const h=d?o():null;super(e,false,u,h);this._nativePannerNode=u;this._orientationX=t(this,d,u.orientationX,b,M);this._orientationY=t(this,d,u.orientationY,b,M);this._orientationZ=t(this,d,u.orientationZ,b,M);this._positionX=t(this,d,u.positionX,b,M);this._positionY=t(this,d,u.positionY,b,M);this._positionZ=t(this,d,u.positionZ,b,M);a(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(e){this._nativePannerNode.coneInnerAngle=e}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(e){this._nativePannerNode.coneOuterAngle=e}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(e){this._nativePannerNode.coneOuterGain=e}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(e){this._nativePannerNode.distanceModel=e}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(e){this._nativePannerNode.maxDistance=e}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(e){this._nativePannerNode.panningModel=e}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(e){this._nativePannerNode.refDistance=e}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(e){this._nativePannerNode.rolloffFactor=e}};const createPannerNodeRendererFactory=(e,t,n,o,r,s,a,c,i,l)=>()=>{const u=new WeakMap;let d=null;const createAudioNode=async(h,f)=>{let p=null;let m=s(h);const v={channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation};const g={...v,coneInnerAngle:m.coneInnerAngle,coneOuterAngle:m.coneOuterAngle,coneOuterGain:m.coneOuterGain,distanceModel:m.distanceModel,maxDistance:m.maxDistance,panningModel:m.panningModel,refDistance:m.refDistance,rolloffFactor:m.rolloffFactor};const C=isOwnedByContext(m,f);if("bufferSize"in m)p=o(f,{...v,gain:1});else if(!C){const e={...g,orientationX:m.orientationX.value,orientationY:m.orientationY.value,orientationZ:m.orientationZ.value,positionX:m.positionX.value,positionY:m.positionY.value,positionZ:m.positionZ.value};m=r(f,e)}u.set(f,p===null?m:p);if(p!==null){if(d===null){if(a===null)throw new Error("Missing the native OfflineAudioContext constructor.");const e=new a(6,h.context.length,f.sampleRate);const o=t(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});o.connect(e.destination);d=(async()=>{const t=await Promise.all([h.orientationX,h.orientationY,h.orientationZ,h.positionX,h.positionY,h.positionZ].map((async(t,o)=>{const r=n(e,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:o===0?1:0});await c(e,t,r.offset);return r})));for(let e=0;e<6;e+=1){t[e].connect(o,0,e);t[e].start(0)}return l(e)})()}const e=await d;const s=o(f,{...v,gain:1});await i(h,f,s);const u=[];for(let t=0;t<e.numberOfChannels;t+=1)u.push(e.getChannelData(t));let m=[u[0][0],u[1][0],u[2][0]];let C=[u[3][0],u[4][0],u[5][0]];let w=o(f,{...v,gain:1});let y=r(f,{...g,orientationX:m[0],orientationY:m[1],orientationZ:m[2],positionX:C[0],positionY:C[1],positionZ:C[2]});s.connect(w).connect(y.inputs[0]);y.connect(p);for(let t=128;t<e.length;t+=128){const e=[u[0][t],u[1][t],u[2][t]];const n=[u[3][t],u[4][t],u[5][t]];if(e.some(((e,t)=>e!==m[t]))||n.some(((e,t)=>e!==C[t]))){m=e;C=n;const a=t/f.sampleRate;w.gain.setValueAtTime(0,a);w=o(f,{...v,gain:0});y=r(f,{...g,orientationX:m[0],orientationY:m[1],orientationZ:m[2],positionX:C[0],positionY:C[1],positionZ:C[2]});w.gain.setValueAtTime(1,a);s.connect(w).connect(y.inputs[0]);y.connect(p)}}return p}if(C){await e(f,h.orientationX,m.orientationX);await e(f,h.orientationY,m.orientationY);await e(f,h.orientationZ,m.orientationZ);await e(f,h.positionX,m.positionX);await e(f,h.positionY,m.positionY);await e(f,h.positionZ,m.positionZ)}else{await c(f,h.orientationX,m.orientationX);await c(f,h.orientationY,m.orientationY);await c(f,h.orientationZ,m.orientationZ);await c(f,h.positionX,m.positionX);await c(f,h.positionY,m.positionY);await c(f,h.positionZ,m.positionZ)}isNativeAudioNodeFaker(m)?await i(h,f,m.inputs[0]):await i(h,f,m);return m};return{render(e,t){const n=u.get(t);return n!==void 0?Promise.resolve(n):createAudioNode(e,t)}}};const V={disableNormalization:false};const createPeriodicWaveConstructor=(e,t,n,o)=>class PeriodicWave{constructor(r,s){const a=t(r);const c=o({...V,...s});const i=e(a,c);n.add(i);return i}static[Symbol.hasInstance](e){return e!==null&&typeof e==="object"&&Object.getPrototypeOf(e)===PeriodicWave.prototype||n.has(e)}};const createRenderAutomation=(e,t)=>(n,o,r)=>{const s=e(o);s.replay(r);return t(o,n,r)};const createRenderInputsOfAudioNode=(e,t,n)=>async(o,r,s)=>{const a=e(o);await Promise.all(a.activeInputs.map(((e,a)=>Array.from(e).map((async([e,c])=>{const i=t(e);const l=await i.render(e,r);const u=o.context.destination;n(e)||o===u&&n(o)||l.connect(s,c,a)})))).reduce(((e,t)=>[...e,...t]),[]))};const createRenderInputsOfAudioParam=(e,t,n)=>async(o,r,s)=>{const a=t(o);await Promise.all(Array.from(a.activeInputs).map((async([t,o])=>{const a=e(t);const c=await a.render(t,r);n(t)||c.connect(s,o)})))};const createRenderNativeOfflineAudioContext=(e,t,n,o)=>r=>e(testPromiseSupport,(()=>testPromiseSupport(r)))?Promise.resolve(e(o,o)).then((e=>{if(!e){const e=n(r,512,0,1);r.oncomplete=()=>{e.onaudioprocess=null;e.disconnect()};e.onaudioprocess=()=>r.currentTime;e.connect(r.destination)}return r.startRendering()})):new Promise((e=>{const n=t(r,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});r.oncomplete=t=>{n.disconnect();e(t.renderedBuffer)};n.connect(r.destination);r.startRendering()}));const createSetActiveAudioWorkletNodeInputs=e=>(t,n)=>{e.set(t,n)};const createSetAudioNodeTailTime=e=>(t,n)=>e.set(t,n);const createStartRendering=(e,t,n,o,r,s,a,c)=>(i,l)=>n(i).render(i,l).then((()=>Promise.all(Array.from(o(l)).map((e=>n(e).render(e,l)))))).then((()=>r(l))).then((n=>{if(typeof n.copyFromChannel!=="function"){a(n);wrapAudioBufferGetChannelDataMethod(n)}else t(s,(()=>s(n)))||c(n);e.add(n);return n}));const j={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0};const createStereoPannerNodeConstructor=(e,t,n,o,r,s)=>class StereoPannerNode extends e{constructor(e,a){const c=r(e);const i={...j,...a};const l=n(c,i);const u=s(c);const d=u?o():null;super(e,false,l,d);this._pan=t(this,u,l.pan)}get pan(){return this._pan}};const createStereoPannerNodeRendererFactory=(e,t,n,o,r)=>()=>{const s=new WeakMap;const createStereoPannerNode=async(a,c)=>{let i=n(a);const l=isOwnedByContext(i,c);if(!l){const e={channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation,pan:i.pan.value};i=t(c,e)}s.set(c,i);l?await e(c,a.pan,i.pan):await o(c,a.pan,i.pan);isNativeAudioNodeFaker(i)?await r(a,c,i.inputs[0]):await r(a,c,i);return i};return{render(e,t){const n=s.get(t);return n!==void 0?Promise.resolve(n):createStereoPannerNode(e,t)}}};const createTestAudioBufferConstructorSupport=e=>()=>{if(e===null)return false;try{new e({length:1,sampleRate:44100})}catch{return false}return true};const createTestAudioBufferCopyChannelMethodsSubarraySupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);const n=t.createBuffer(1,1,44100);if(n.copyToChannel===void 0)return true;const o=new Float32Array(2);try{n.copyFromChannel(o,0,0)}catch{return false}return true};const createTestAudioContextCloseMethodSupport=e=>()=>{if(e===null)return false;if(e.prototype!==void 0&&e.prototype.close!==void 0)return true;const t=new e;const n=t.close!==void 0;try{t.close()}catch{}return n};const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport=e=>()=>{if(e===null)return Promise.resolve(false);const t=new e(1,1,44100);return new Promise((e=>{let n=true;const resolvePromise=o=>{if(n){n=false;t.startRendering();e(o instanceof TypeError)}};let o;try{o=t.decodeAudioData(null,(()=>{}),resolvePromise)}catch(e){resolvePromise(e)}o!==void 0&&o.catch(resolvePromise)}))};const createTestAudioContextOptionsSupport=e=>()=>{if(e===null)return false;let t;try{t=new e({latencyHint:"balanced"})}catch{return false}t.close();return true};const createTestAudioNodeConnectMethodSupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);const n=t.createGain();const o=n.connect(n)===n;n.disconnect(n);return o};const createTestAudioWorkletProcessorNoOutputsSupport=(e,t)=>async()=>{if(e===null)return true;if(t===null)return false;const n=new Blob(['let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"});const o=new MessageChannel;const r=new t(1,128,44100);const s=URL.createObjectURL(n);let a=false;try{await r.audioWorklet.addModule(s);const t=new e(r,"a",{numberOfOutputs:0});const n=r.createOscillator();await new Promise((e=>{t.port.onmessage=()=>e();t.port.postMessage(o.port2,[o.port2])}));t.port.onmessage=()=>a=true;n.connect(t);n.start(0);await r.startRendering();a=await new Promise((e=>{o.port1.onmessage=({data:t})=>e(t===1);o.port1.postMessage(0)}))}catch{}finally{o.port1.close();URL.revokeObjectURL(s)}return a};const createTestAudioWorkletProcessorPostMessageSupport=(e,t)=>async()=>{if(e===null)return true;if(t===null)return false;const n=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"});const o=new t(1,128,44100);const r=URL.createObjectURL(n);let s=false;let a=false;try{await o.audioWorklet.addModule(r);const t=new e(o,"a",{numberOfOutputs:0});const n=o.createOscillator();t.port.onmessage=()=>s=true;t.onprocessorerror=()=>a=true;n.connect(t);n.start(0);await o.startRendering();await new Promise((e=>setTimeout(e)))}catch{}finally{URL.revokeObjectURL(r)}return s&&!a};const createTestChannelMergerNodeChannelCountSupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);const n=t.createChannelMerger();if(n.channelCountMode==="max")return true;try{n.channelCount=2}catch{return true}return false};const createTestConstantSourceNodeAccurateSchedulingSupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);if(t.createConstantSource===void 0)return true;const n=t.createConstantSource();return n.offset.maxValue!==Number.POSITIVE_INFINITY};const createTestConvolverNodeBufferReassignabilitySupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);const n=t.createConvolver();n.buffer=t.createBuffer(1,1,t.sampleRate);try{n.buffer=t.createBuffer(1,1,t.sampleRate)}catch{return false}return true};const createTestConvolverNodeChannelCountSupport=e=>()=>{if(e===null)return false;const t=new e(1,1,44100);const n=t.createConvolver();try{n.channelCount=1}catch{return false}return true};const createTestIsSecureContextSupport=e=>()=>e!==null&&e.hasOwnProperty("isSecureContext");const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport=e=>()=>{if(e===null)return false;const t=new e;try{t.createMediaStreamSource(new MediaStream);return false}catch(e){return true}finally{t.close()}};const createTestOfflineAudioContextCurrentTimeSupport=(e,t)=>()=>{if(t===null)return Promise.resolve(false);const n=new t(1,1,44100);const o=e(n,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise((e=>{n.oncomplete=()=>{o.disconnect();e(n.currentTime!==0)};n.startRendering()}))};const createTestStereoPannerNodeDefaultValueSupport=e=>()=>{if(e===null)return Promise.resolve(false);const t=new e(1,1,44100);if(t.createStereoPanner===void 0)return Promise.resolve(true);if(t.createConstantSource===void 0)return Promise.resolve(true);const n=t.createConstantSource();const o=t.createStereoPanner();n.channelCount=1;n.offset.value=1;o.channelCount=1;n.start();n.connect(o).connect(t.destination);return t.startRendering().then((e=>e.getChannelData(0)[0]!==1))};const createUnknownError=()=>new DOMException("","UnknownError");const q={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"};const createWaveShaperNodeConstructor=(e,t,n,o,r,s,a)=>class WaveShaperNode extends e{constructor(e,t){const c=r(e);const i={...q,...t};const l=n(c,i);const u=s(c);const d=u?o():null;super(e,true,l,d);this._isCurveNullified=false;this._nativeWaveShaperNode=l;a(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(e){if(e===null){this._isCurveNullified=true;this._nativeWaveShaperNode.curve=new Float32Array([0,0])}else{if(e.length<2)throw t();this._isCurveNullified=false;this._nativeWaveShaperNode.curve=e}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(e){this._nativeWaveShaperNode.oversample=e}};const createWaveShaperNodeRendererFactory=(e,t,n)=>()=>{const o=new WeakMap;const createWaveShaperNode=async(r,s)=>{let a=t(r);const c=isOwnedByContext(a,s);if(!c){const t={channelCount:a.channelCount,channelCountMode:a.channelCountMode,channelInterpretation:a.channelInterpretation,curve:a.curve,oversample:a.oversample};a=e(s,t)}o.set(s,a);isNativeAudioNodeFaker(a)?await n(r,s,a.inputs[0]):await n(r,s,a);return a};return{render(e,t){const n=o.get(t);return n!==void 0?Promise.resolve(n):createWaveShaperNode(e,t)}}};const createWindow=()=>typeof window==="undefined"?null:window;const createWrapAudioBufferCopyChannelMethods=(e,t)=>n=>{n.copyFromChannel=(o,r,s=0)=>{const a=e(s);const c=e(r);if(c>=n.numberOfChannels)throw t();const i=n.length;const l=n.getChannelData(c);const u=o.length;for(let e=a<0?-a:0;e+a<i&&e<u;e+=1)o[e]=l[e+a]};n.copyToChannel=(o,r,s=0)=>{const a=e(s);const c=e(r);if(c>=n.numberOfChannels)throw t();const i=n.length;const l=n.getChannelData(c);const u=o.length;for(let e=a<0?-a:0;e+a<i&&e<u;e+=1)l[e+a]=o[e]}};const createWrapAudioBufferCopyChannelMethodsOutOfBounds=e=>t=>{t.copyFromChannel=(n=>(o,r,s=0)=>{const a=e(s);const c=e(r);if(a<t.length)return n.call(t,o,c,a)})(t.copyFromChannel);t.copyToChannel=(n=>(o,r,s=0)=>{const a=e(s);const c=e(r);if(a<t.length)return n.call(t,o,c,a)})(t.copyToChannel)};const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer=e=>(t,n)=>{const o=n.createBuffer(1,1,44100);t.buffer===null&&(t.buffer=o);e(t,"buffer",(e=>()=>{const n=e.call(t);return n===o?null:n}),(e=>n=>e.call(t,n===null?o:n)))};const createWrapChannelMergerNode=(e,t)=>(n,o)=>{o.channelCount=1;o.channelCountMode="explicit";Object.defineProperty(o,"channelCount",{get:()=>1,set:()=>{throw e()}});Object.defineProperty(o,"channelCountMode",{get:()=>"explicit",set:()=>{throw e()}});const r=n.createBufferSource();const whenConnected=()=>{const e=o.numberOfInputs;for(let t=0;t<e;t+=1)r.connect(o,0,t)};const whenDisconnected=()=>r.disconnect(o);t(o,whenConnected,whenDisconnected)};const getFirstSample=(e,t,n)=>{if(e.copyFromChannel===void 0)return e.getChannelData(n)[0];e.copyFromChannel(t,n);return t[0]};const isDCCurve=e=>{if(e===null)return false;const t=e.length;return t%2!==0?e[Math.floor(t/2)]!==0:e[t/2-1]+e[t/2]!==0};const overwriteAccessors=(e,t,n,o)=>{let r=e;while(!r.hasOwnProperty(t))r=Object.getPrototypeOf(r);const{get:s,set:a}=Object.getOwnPropertyDescriptor(r,t);Object.defineProperty(e,t,{get:n(s),set:o(a)})};const sanitizeAudioWorkletNodeOptions=e=>({...e,outputChannelCount:e.outputChannelCount!==void 0?e.outputChannelCount:e.numberOfInputs===1&&e.numberOfOutputs===1?[e.channelCount]:Array.from({length:e.numberOfOutputs},(()=>1))});const sanitizeChannelSplitterOptions=e=>({...e,channelCount:e.numberOfOutputs});const sanitizePeriodicWaveOptions=e=>{const{imag:t,real:n}=e;return t===void 0?n===void 0?{...e,imag:[0,0],real:[0,0]}:{...e,imag:Array.from(n,(()=>0)),real:n}:n===void 0?{...e,imag:t,real:Array.from(t,(()=>0))}:{...e,imag:t,real:n}};const setValueAtTimeUntilPossible=(e,t,n)=>{try{e.setValueAtTime(t,n)}catch(o){if(o.code!==9)throw o;setValueAtTimeUntilPossible(e,t,n+1e-7)}};const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport=e=>{const t=e.createBufferSource();t.start();try{t.start()}catch{return true}return false};const testAudioBufferSourceNodeStartMethodOffsetClampingSupport=e=>{const t=e.createBufferSource();const n=e.createBuffer(1,1,44100);t.buffer=n;try{t.start(0,1)}catch{return false}return true};const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport=e=>{const t=e.createBufferSource();t.start();try{t.stop()}catch{return false}return true};const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport=e=>{const t=e.createOscillator();try{t.start(-1)}catch(e){return e instanceof RangeError}return false};const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport=e=>{const t=e.createBuffer(1,1,44100);const n=e.createBufferSource();n.buffer=t;n.start();n.stop();try{n.stop();return true}catch{return false}};const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport=e=>{const t=e.createOscillator();try{t.stop(-1)}catch(e){return e instanceof RangeError}return false};const testAudioWorkletNodeOptionsClonability=e=>{const{port1:t,port2:n}=new MessageChannel;try{t.postMessage(e)}finally{t.close();n.close()}};const testDomExceptionConstructorSupport=()=>{try{new DOMException}catch{return false}return true};const testTransferablesSupport=()=>new Promise((e=>{const t=new ArrayBuffer(0);const{port1:n,port2:o}=new MessageChannel;n.onmessage=({data:t})=>e(t!==null);o.postMessage(t,[t])}));const wrapAudioBufferSourceNodeStartMethodOffsetClamping=e=>{e.start=(t=>(n=0,o=0,r)=>{const s=e.buffer;const a=s===null?o:Math.min(s.duration,o);s!==null&&a>s.duration-.5/e.context.sampleRate?t.call(e,n,0,0):t.call(e,n,a,r)})(e.start)};const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls=(e,t)=>{const n=t.createGain();e.connect(n);const o=(t=>()=>{t.call(e,n);e.removeEventListener("ended",o)})(e.disconnect);e.addEventListener("ended",o);interceptConnections(e,n);e.stop=(t=>{let o=false;return(r=0)=>{if(o)try{t.call(e,r)}catch{n.gain.setValueAtTime(0,r)}else{t.call(e,r);o=true}}})(e.stop)};const wrapEventListener=(e,t)=>n=>{const o={value:e};Object.defineProperties(n,{currentTarget:o,target:o});return typeof t==="function"?t.call(e,n):t.handleEvent.call(e,n)};const X=createAddActiveInputConnectionToAudioNode(insertElementInSet);const Y=createAddPassiveInputConnectionToAudioNode(insertElementInSet);const G=createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);const Z=new WeakMap;const z=createGetAudioNodeTailTime(Z);const U=createCacheTestResult(new Map,new WeakMap);const Q=createWindow();const H=createNativeAnalyserNodeFactory(U,createIndexSizeError);const $=createGetAudioNodeRenderer(getAudioNodeConnections);const J=createRenderInputsOfAudioNode(getAudioNodeConnections,$,isPartOfACycle);const K=createAnalyserNodeRendererFactory(H,getNativeAudioNode,J);const ee=createGetNativeContext(f);const te=createNativeOfflineAudioContextConstructor(Q);const ne=createIsNativeOfflineAudioContext(te);const oe=new WeakMap;const re=createEventTargetConstructor(wrapEventListener);const se=createNativeAudioContextConstructor(Q);const ae=createIsNativeAudioContext(se);const ce=createIsNativeAudioNode(Q);const ie=createIsNativeAudioParam(Q);const le=createNativeAudioWorkletNodeConstructor(Q);const ue=createAudioNodeConstructor(createAddAudioNodeConnections(l),createAddConnectionToAudioNode(X,Y,connectNativeAudioNodeToNativeAudioNode,G,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,z,getEventListenersOfAudioNode,getNativeAudioNode,insertElementInSet,isActiveAudioNode,isPartOfACycle,isPassiveAudioNode),U,createIncrementCycleCounterFactory(m,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,isActiveAudioNode),createIndexSizeError,createInvalidAccessError,createNotSupportedError,createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode,m,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,ee,isActiveAudioNode,ne),createDetectCycles(oe,getAudioNodeConnections,getValueForKey),re,ee,ae,ce,ie,ne,le);const de=createAnalyserNodeConstructor(ue,K,createIndexSizeError,H,ee,ne);const he=new WeakSet;const fe=createNativeAudioBufferConstructor(Q);const pe=createConvertNumberToUnsignedLong(new Uint32Array(1));const me=createWrapAudioBufferCopyChannelMethods(pe,createIndexSizeError);const ve=createWrapAudioBufferCopyChannelMethodsOutOfBounds(pe);const ge=createAudioBufferConstructor(he,U,createNotSupportedError,fe,te,createTestAudioBufferConstructorSupport(fe),me,ve);const Ce=createAddSilentConnection(createNativeGainNode);const we=createRenderInputsOfAudioParam($,getAudioParamConnections,isPartOfACycle);const ye=createConnectAudioParam(we);const _e=createNativeAudioBufferSourceNodeFactory(Ce,U,testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,testAudioBufferSourceNodeStartMethodOffsetClampingSupport,testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioBufferSourceNodeStartMethodOffsetClamping,createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);const Me=createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections),we);const be=createAudioBufferSourceNodeRendererFactory(ye,_e,getNativeAudioNode,Me,J);const Ae=createAudioParamFactory(createAddAudioParamConnections(d),oe,h,createAudioParamRenderer,t,n,o,r,s,a,c,se,setValueAtTimeUntilPossible);const Oe=createAudioBufferSourceNodeConstructor(ue,be,Ae,createInvalidStateError,_e,ee,ne,wrapEventListener);const xe=createAudioDestinationNodeConstructor(ue,createAudioDestinationNodeRenderer,createIndexSizeError,createInvalidStateError,createNativeAudioDestinationNodeFactory(createNativeGainNode,overwriteAccessors),ee,ne,J);const Ne=createBiquadFilterNodeRendererFactory(ye,createNativeBiquadFilterNode,getNativeAudioNode,Me,J);const Ie=createSetAudioNodeTailTime(Z);const Ee=createBiquadFilterNodeConstructor(ue,Ae,Ne,createInvalidAccessError,createNativeBiquadFilterNode,ee,ne,Ie);const Se=createMonitorConnections(insertElementInSet,ce);const Te=createWrapChannelMergerNode(createInvalidStateError,Se);const ke=createNativeChannelMergerNodeFactory(se,Te);const De=createChannelMergerNodeRendererFactory(ke,getNativeAudioNode,J);const Pe=createChannelMergerNodeConstructor(ue,De,ke,ee,ne);const Re=createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode,getNativeAudioNode,J);const Fe=createChannelSplitterNodeConstructor(ue,Re,createNativeChannelSplitterNode,ee,ne,sanitizeChannelSplitterOptions);const Le=createNativeConstantSourceNodeFakerFactory(Ce,_e,createNativeGainNode,Se);const We=createNativeConstantSourceNodeFactory(Ce,U,Le,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);const Be=createConstantSourceNodeRendererFactory(ye,We,getNativeAudioNode,Me,J);const Ve=createConstantSourceNodeConstructor(ue,Ae,Be,We,ee,ne,wrapEventListener);const je=createNativeConvolverNodeFactory(createNotSupportedError,overwriteAccessors);const qe=createConvolverNodeRendererFactory(je,getNativeAudioNode,J);const Xe=createConvolverNodeConstructor(ue,qe,je,ee,ne,Ie);const Ye=createDelayNodeRendererFactory(ye,createNativeDelayNode,getNativeAudioNode,Me,J);const Ge=createDelayNodeConstructor(ue,Ae,Ye,createNativeDelayNode,ee,ne,Ie);const Ze=createNativeDynamicsCompressorNodeFactory(createNotSupportedError);const ze=createDynamicsCompressorNodeRendererFactory(ye,Ze,getNativeAudioNode,Me,J);const Ue=createDynamicsCompressorNodeConstructor(ue,Ae,ze,Ze,createNotSupportedError,ee,ne,Ie);const Qe=createGainNodeRendererFactory(ye,createNativeGainNode,getNativeAudioNode,Me,J);const He=createGainNodeConstructor(ue,Ae,Qe,createNativeGainNode,ee,ne);const $e=createNativeIIRFilterNodeFakerFactory(createInvalidAccessError,createInvalidStateError,createNativeScriptProcessorNode,createNotSupportedError);const Je=createRenderNativeOfflineAudioContext(U,createNativeGainNode,createNativeScriptProcessorNode,createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode,te));const Ke=createIIRFilterNodeRendererFactory(_e,getNativeAudioNode,te,J,Je);const et=createNativeIIRFilterNodeFactory($e);const tt=createIIRFilterNodeConstructor(ue,et,Ke,ee,ne,Ie);const nt=createAudioListenerFactory(Ae,ke,We,createNativeScriptProcessorNode,createNotSupportedError,getFirstSample,ne,overwriteAccessors);const ot=new WeakMap;const rt=createMinimalBaseAudioContextConstructor(xe,nt,re,ne,ot,wrapEventListener);const st=createNativeOscillatorNodeFactory(Ce,U,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);const at=createOscillatorNodeRendererFactory(ye,st,getNativeAudioNode,Me,J);const ct=createOscillatorNodeConstructor(ue,Ae,st,at,ee,ne,wrapEventListener);const it=createConnectedNativeAudioBufferSourceNodeFactory(_e);const lt=createNativeWaveShaperNodeFakerFactory(it,createInvalidStateError,createNativeGainNode,isDCCurve,Se);const ut=createNativeWaveShaperNodeFactory(it,createInvalidStateError,lt,isDCCurve,Se,se,overwriteAccessors);const dt=createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode,createInvalidStateError,ke,createNativeGainNode,createNativeScriptProcessorNode,ut,createNotSupportedError,disconnectNativeAudioNodeFromNativeAudioNode,getFirstSample,Se);const ht=createNativePannerNodeFactory(dt);const ft=createPannerNodeRendererFactory(ye,ke,We,createNativeGainNode,ht,getNativeAudioNode,te,Me,J,Je);const pt=createPannerNodeConstructor(ue,Ae,ht,ft,ee,ne,Ie);const mt=createNativePeriodicWaveFactory(createIndexSizeError);const vt=createPeriodicWaveConstructor(mt,ee,new WeakSet,sanitizePeriodicWaveOptions);const gt=createNativeStereoPannerNodeFakerFactory(ke,createNativeChannelSplitterNode,createNativeGainNode,ut,createNotSupportedError,Se);const Ct=createNativeStereoPannerNodeFactory(gt,createNotSupportedError);const wt=createStereoPannerNodeRendererFactory(ye,Ct,getNativeAudioNode,Me,J);const yt=createStereoPannerNodeConstructor(ue,Ae,Ct,wt,ee,ne);const _t=createWaveShaperNodeRendererFactory(ut,getNativeAudioNode,J);const Mt=createWaveShaperNodeConstructor(ue,createInvalidStateError,ut,_t,ee,ne,Ie);const bt=createIsSecureContext(Q);const At=createExposeCurrentFrameAndCurrentTime(Q);const Ot=new WeakMap;const xt=createGetOrCreateBackupOfflineAudioContext(Ot,te);const Nt=bt?createAddAudioWorkletModule(U,createNotSupportedError,createEvaluateSource(Q),At,createFetchSource(createAbortError),ee,xt,ne,le,new WeakMap,new WeakMap,createTestAudioWorkletProcessorPostMessageSupport(le,te),Q):void 0;const It=createIsNativeContext(ae,ne);const Et=createDecodeAudioData(he,U,createDataCloneError,createEncodingError,new WeakSet,ee,It,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,testPromiseSupport,me,ve);const St=createBaseAudioContextConstructor(Nt,de,ge,Oe,Ee,Pe,Fe,Ve,Xe,Et,Ge,Ue,He,tt,rt,ct,pt,vt,yt,Mt);const Tt=createMediaElementAudioSourceNodeConstructor(ue,createNativeMediaElementAudioSourceNode,ee,ne);const kt=createMediaStreamAudioDestinationNodeConstructor(ue,createNativeMediaStreamAudioDestinationNode,ee,ne);const Dt=createMediaStreamAudioSourceNodeConstructor(ue,createNativeMediaStreamAudioSourceNode,ee,ne);const Pt=createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError,ne);const Rt=createMediaStreamTrackAudioSourceNodeConstructor(ue,Pt,ee);const Ft=createAudioContextConstructor(St,createInvalidStateError,createNotSupportedError,createUnknownError,Tt,kt,Dt,Rt,se);const Lt=createGetUnrenderedAudioWorkletNodes(ot);const Wt=createAddUnrenderedAudioWorkletNode(Lt);const Bt=createConnectMultipleOutputs(createIndexSizeError);const Vt=createDeleteUnrenderedAudioWorkletNode(Lt);const jt=createDisconnectMultipleOutputs(createIndexSizeError);const qt=new WeakMap;const Xt=createGetActiveAudioWorkletNodeInputs(qt,getValueForKey);const Yt=createNativeAudioWorkletNodeFakerFactory(Bt,createIndexSizeError,createInvalidStateError,ke,createNativeChannelSplitterNode,We,createNativeGainNode,createNativeScriptProcessorNode,createNotSupportedError,jt,At,Xt,Se);const Gt=createNativeAudioWorkletNodeFactory(createInvalidStateError,Yt,createNativeGainNode,createNotSupportedError,Se);const Zt=createAudioWorkletNodeRendererFactory(ye,Bt,_e,ke,createNativeChannelSplitterNode,We,createNativeGainNode,Vt,jt,At,getNativeAudioNode,le,te,Me,J,Je);const zt=createGetBackupOfflineAudioContext(Ot);const Ut=createSetActiveAudioWorkletNodeInputs(qt);const Qt=bt?createAudioWorkletNodeConstructor(Wt,ue,Ae,Zt,Gt,getAudioNodeConnections,zt,ee,ne,le,sanitizeAudioWorkletNodeOptions,Ut,testAudioWorkletNodeOptionsClonability,wrapEventListener):void 0;const Ht=createMinimalAudioContextConstructor(createInvalidStateError,createNotSupportedError,createUnknownError,rt,se);const $t=createCreateNativeOfflineAudioContext(createNotSupportedError,te);const Jt=createStartRendering(he,U,$,Lt,Je,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,me,ve);const Kt=createMinimalOfflineAudioContextConstructor(U,createInvalidStateError,$t,rt,Jt);const en=createOfflineAudioContextConstructor(St,U,createInvalidStateError,$t,Jt);const tn=createIsAnyAudioContext(f,ae);const nn=createIsAnyAudioNode(u,ce);const on=createIsAnyAudioParam(h,ie);const rn=createIsAnyOfflineAudioContext(f,ne);const isSupported=()=>createIsSupportedPromise(U,createTestAudioBufferCopyChannelMethodsSubarraySupport(te),createTestAudioContextCloseMethodSupport(se),createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(te),createTestAudioContextOptionsSupport(se),createTestAudioNodeConnectMethodSupport(te),createTestAudioWorkletProcessorNoOutputsSupport(le,te),createTestChannelMergerNodeChannelCountSupport(te),createTestConstantSourceNodeAccurateSchedulingSupport(te),createTestConvolverNodeBufferReassignabilitySupport(te),createTestConvolverNodeChannelCountSupport(te),testDomExceptionConstructorSupport,createTestIsSecureContextSupport(Q),createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(se),createTestStereoPannerNodeDefaultValueSupport(te),testTransferablesSupport);export{de as AnalyserNode,ge as AudioBuffer,Oe as AudioBufferSourceNode,Ft as AudioContext,Qt as AudioWorkletNode,Ee as BiquadFilterNode,Pe as ChannelMergerNode,Fe as ChannelSplitterNode,Ve as ConstantSourceNode,Xe as ConvolverNode,Ge as DelayNode,Ue as DynamicsCompressorNode,He as GainNode,tt as IIRFilterNode,Tt as MediaElementAudioSourceNode,kt as MediaStreamAudioDestinationNode,Dt as MediaStreamAudioSourceNode,Rt as MediaStreamTrackAudioSourceNode,Ht as MinimalAudioContext,Kt as MinimalOfflineAudioContext,en as OfflineAudioContext,ct as OscillatorNode,pt as PannerNode,vt as PeriodicWave,yt as StereoPannerNode,Mt as WaveShaperNode,Nt as addAudioWorkletModule,Et as decodeAudioData,tn as isAnyAudioContext,nn as isAnyAudioNode,on as isAnyAudioParam,rn as isAnyOfflineAudioContext,isSupported};

